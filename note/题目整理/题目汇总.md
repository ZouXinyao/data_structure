## 牛人的题解：

感谢各路大佬：

https://leetcode-cn.com/u/xiao_ben_zhu/

https://leetcode-cn.com/u/carlsun-2/





# 一、数组

#### [283. 移动零](https://leetcode-cn.com/problems/move-zeroes/)

难度简单994收藏分享切换为英文接收动态反馈

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**示例:**

```
输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
```

**说明**:

1. 必须在原数组上操作，不能拷贝额外的数组。
2. 尽量减少操作次数。

```go
func moveZeroes(nums []int)  {
	l, r := 0, 1
	for ; r < len(nums); r++ {
		if nums[l] == 0 && nums[r] != 0 {
			nums[l], nums[r] = nums[r], nums[l]
			l++
		} else if nums[l] != 0 {
			l++
		}
	}
}
```



#### [88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)

难度简单802收藏分享切换为英文接收动态反馈

给你两个有序整数数组 `nums1` 和 `nums2`，请你将 `nums2` 合并到 `nums1` 中*，*使 `nums1` 成为一个有序数组。

初始化 `nums1` 和 `nums2` 的元素数量分别为 `m` 和 `n` 。你可以假设 `nums1` 的空间大小等于 `m + n`，这样它就有足够的空间保存来自 `nums2` 的元素。

**示例 1：**

```
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
```

**示例 2：**

```
输入：nums1 = [1], m = 1, nums2 = [], n = 0
输出：[1]
```

**提示：**

- `nums1.length == m + n`
- `nums2.length == n`
- `0 <= m, n <= 200`
- `1 <= m + n <= 200`
- `-109 <= nums1[i], nums2[i] <= 109`

```go
func merge(nums1 []int, m int, nums2 []int, n int) {
	for p := m + n; m > 0 && n > 0; p-- {
		if nums2[n-1] >= nums1[m-1] {
			nums1[p-1] = nums2[n-1]
			n--
		} else {
			nums1[p-1] = nums1[m-1]
			m--
		}
	}
	for ; n-1 >= 0; n-- {
		nums1[n-1] = nums2[n-1]
	}
}
```



#### [66. 加一](https://leetcode-cn.com/problems/plus-one/)

难度简单645收藏分享切换为英文接收动态反馈

给定一个由 **整数** 组成的 **非空** 数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储**单个**数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。

**示例 1：**

```
输入：digits = [1,2,3]
输出：[1,2,4]
解释：输入数组表示数字 123。
```

**示例 2：**

```
输入：digits = [4,3,2,1]
输出：[4,3,2,2]
解释：输入数组表示数字 4321。
```

**示例 3：**

```
输入：digits = [0]
输出：[1]
```

**提示：**

- `1 <= digits.length <= 100`
- `0 <= digits[i] <= 9`

```go
func plusOne(digits []int) []int {
	for i:=len(digits)-1; i>=0; i-- {
		if digits[i] < 9 {  // 当前位置不用进位，+1，然后直接返回
			digits[i]++
			return digits
		} else {            // 要进位，当前位置置0
			digits[i] = 0
		}
	}
	return append([]int{1}, digits...)
}
```



#### [26. 删除有序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

难度简单1888收藏分享切换为英文接收动态反馈

给你一个有序数组 `nums` ，请你**[ 原地](http://baike.baidu.com/item/原地算法)** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 **[原地 ](https://baike.baidu.com/item/原地算法)修改输入数组** 并在使用 O(1) 额外空间的条件下完成。

 

**说明:**

为什么返回数值是整数，但输出的答案是数组呢?

请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:

```
// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
```

**示例 1：**

```
输入：nums = [1,1,2]
输出：2, nums = [1,2]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
```

**示例 2：**

```
输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4]
解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。
```

**提示：**

- `0 <= nums.length <= 3 * 104`
- `-104 <= nums[i] <= 104`
- `nums` 已按升序排列

```go
// 双指针，只用管前面不重复的元素，后面的那些不用管。
func removeDuplicates(nums []int) int {
	if len(nums) < 2 { return len(nums) }
	l, r := 0, 1
	for ; r < len(nums); r++ {
		if nums[l] != nums[r] {
			l++
			nums[l] = nums[r]
		}
	}
	return l+1
}
```



#### [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

难度简单1540收藏分享切换为英文接收动态反馈

假设你正在爬楼梯。需要 *n* 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**注意：**给定 *n* 是一个正整数。

**示例 1：**

```
输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
```

**示例 2：**

```
输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶
```

```go
func climbStairs(n int) int {
	if n <= 3 { return n }
	first, second := 1, 2
	res := 0
	for i := 3; i <= n; i++{
		res = first + second
		first, second = second, res
	}
	return res
}
```



#### [11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)

难度中等2274收藏分享切换为英文接收动态反馈

给你 `n` 个非负整数 `a1，a2，...，a``n`，每个数代表坐标中的一个点 `(i, ai)` 。在坐标内画 `n` 条垂直线，垂直线 `i` 的两个端点分别为 `(i, ai)` 和 `(i, 0)` 。找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。

**说明：**你不能倾斜容器。

**示例 1：**

![img](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg)

```
输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
```

**示例 2：**

```
输入：height = [1,1]
输出：1
```

**示例 3：**

```
输入：height = [4,3,2,1,4]
输出：16
```

**示例 4：**

```
输入：height = [1,2,1]
输出：2
```

**提示：**

- `n = height.length`
- `2 <= n <= 3 * 104`
- `0 <= height[i] <= 3 * 104`

```go
// 双指针
func maxArea(height []int) int {
	l, r, res := 0, len(height) - 1, 0
	for l < r {
		res = max(res, min(height[l], height[r]) * (r - l))
		// 判断条件是哪边矮，移哪边
		if height[l] < height[r] {
			l++
		} else {
			r--
		}
	}
	return res
}

func max(a, b int) int {
	if a>b {return a}
	return b
}

func min(a, b int) int {
	if a<b {return a}
	return b
}
```



#### [15. 三数之和](https://leetcode-cn.com/problems/3sum/)

难度中等3095收藏分享切换为英文接收动态反馈

给你一个包含 `n` 个整数的数组 `nums`，判断 `nums` 中是否存在三个元素 *a，b，c ，*使得 *a + b + c =* 0 ？请你找出所有和为 `0` 且不重复的三元组。

**注意：**答案中不可以包含重复的三元组。

**示例 1：**

```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
```

**示例 2：**

```
输入：nums = []
输出：[]
```

**示例 3：**

```
输入：nums = [0]
输出：[]
```

**提示：**

- `0 <= nums.length <= 3000`
- `-105 <= nums[i] <= 105`

```go
func threeSum(nums []int) [][]int {
	sort.Ints(nums)
	var res [][]int
	for i := 0; i < len(nums) - 2; i++ {
		// 去重，需要第一个数不重复
		if i > 0 && nums[i] == nums[i - 1] {
			continue
		}
		l, r := i + 1, len(nums) - 1
		for l < r {
			// 去重，也需要第一个数不重复
			if l > i + 1 && nums[l] == nums[l - 1] {
				l++
				continue
			}
			if nums[i] + nums[l] + nums[r] < 0 {
				l++
			} else if nums[i] + nums[l] + nums[r] > 0 {
				r--
			} else {
				res = append(res, []int{nums[i], nums[l], nums[r]})
				l++
				r--
			}
		}
	}
	return res
}
```



#### [189. 旋转数组](https://leetcode-cn.com/problems/rotate-array/)

难度中等921收藏分享切换为英文接收动态反馈

给定一个数组，将数组中的元素向右移动 `k` 个位置，其中 `k` 是非负数。

**进阶：**

- 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。
- 你可以使用空间复杂度为 O(1) 的 **原地** 算法解决这个问题吗？

**示例 1:**

```
输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4]
```

**示例 2:**

```
输入：nums = [-1,-100,3,99], k = 2
输出：[3,99,-1,-100]
解释: 
向右旋转 1 步: [99,-1,-100,3]
向右旋转 2 步: [3,99,-1,-100]
```

**提示：**

- `1 <= nums.length <= 2 * 104`
- `-231 <= nums[i] <= 231 - 1`
- `0 <= k <= 105`

```go
// 3次换序
func rotate(nums []int, k int)  {
	l, r := 0, len(nums) - 1
	for l < r {
		nums[l], nums[r] = nums[r], nums[l]
		r--
		l++
	}
	l, r = 0, (k % len(nums)) - 1
	for l < r {
		nums[l], nums[r] = nums[r], nums[l]
		r--
		l++
	}
	l, r = k % len(nums), len(nums) - 1
	for l < r {
		nums[l], nums[r] = nums[r], nums[l]
		r--
		l++
	}
}
```



# 二、链表

#### [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

难度简单1602收藏分享切换为英文接收动态反馈

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg)

```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**示例 2：**

```
输入：l1 = [], l2 = []
输出：[]
```

**示例 3：**

```
输入：l1 = [], l2 = [0]
输出：[0]
```

**提示：**

- 两个链表的节点数目范围是 `[0, 50]`
- `-100 <= Node.val <= 100`
- `l1` 和 `l2` 均按 **非递减顺序** 排列

```go
// 新建node
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
	prehead := &ListNode{}
	result := prehead
	for l1 != nil && l2 != nil {
		if l1.Val < l2.Val {
			prehead.Next = l1
			l1 = l1.Next
		}else{
			prehead.Next = l2
			l2 = l2.Next
		}
		prehead = prehead.Next
	}
	if l1 != nil {
		prehead.Next = l1
	}
	if l2 != nil {
		prehead.Next = l2
	}
	return result.Next
}
```



#### [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

难度简单1583收藏分享切换为英文接收动态反馈

反转一个单链表。

**示例:**

```
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
```



#### [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

难度中等858收藏分享切换为英文接收动态反馈

给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。

**你不能只是单纯的改变节点内部的值**，而是需要实际的进行节点交换。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg)

```
输入：head = [1,2,3,4]
输出：[2,1,4,3]
```

**示例 2：**

```
输入：head = []
输出：[]
```

**示例 3：**

```
输入：head = [1]
输出：[1]
```

**提示：**

- 链表中节点的数目在范围 `[0, 100]` 内
- `0 <= Node.val <= 100`

```go
func swapPairs(head *ListNode) *ListNode {
	res := &ListNode{0, head}
	prev, curr := res, head
	for curr != nil && curr.Next != nil {
		next := curr.Next
		// 互换位置过程
		prev.Next = next
		curr.Next = next.Next
		next.Next = curr
		// 换位置过程
		prev, curr = curr, curr.Next
	}
	return res.Next
}
```



#### [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

难度简单982收藏分享切换为英文接收动态反馈

给定一个链表，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。

如果链表中存在环，则返回 `true` 。 否则，返回 `false` 。

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png)

```
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```

**示例 2：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png)

```
输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。
```

**示例 3：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png)

```
输入：head = [1], pos = -1
输出：false
解释：链表中没有环。
```

**提示：**

- 链表中节点的数目范围是 `[0, 104]`
- `-105 <= Node.val <= 105`
- `pos` 为 `-1` 或者链表中的一个 **有效索引** 。

```go
// 快慢指针
func hasCycle(head *ListNode) bool {
	s, f := head, head
	for s != nil && f != nil && f.Next != nil {
		s = s.Next
		f = f.Next.Next
		if f == s { return true }
	}
	return false
}
```



#### [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

难度中等909收藏分享切换为英文接收动态反馈

给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 `null`。

为了表示给定链表中的环，我们使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 `pos` 是 `-1`，则在该链表中没有环。**注意，`pos` 仅仅是用于标识环的情况，并不会作为参数传递到函数中。**

**说明：**不允许修改给定的链表。

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png)

```
输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。
```

**示例 2：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png)

```
输入：head = [1,2], pos = 0
输出：返回索引为 0 的链表节点
解释：链表中有一个环，其尾部连接到第一个节点。
```

**示例 3：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png)

```
输入：head = [1], pos = -1
输出：返回 null
解释：链表中没有环。
```

**提示：**

- 链表中节点的数目范围在范围 `[0, 104]` 内
- `-105 <= Node.val <= 105`
- `pos` 的值为 `-1` 或者链表中的一个有效索引

```go
func detectCycle(head *ListNode) *ListNode {
	s, f := head, head
	for s != nil && f != nil && f.Next != nil {
		s = s.Next
		f = f.Next.Next
		// 当判断为环时，需要做的就是画个图，s距交点的举例=head到交点的举例
		if f == s {
			f = head
			for f != s {
				s, f = s.Next, f.Next
			}
			return f
		}
	}
	return nil
}
```



# 三、栈和队列

#### [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

难度简单2244收藏分享切换为英文接收动态反馈

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。

**示例 1：**

```
输入：s = "()"
输出：true
```

**示例 2：**

```
输入：s = "()[]{}"
输出：true
```

**示例 3：**

```
输入：s = "(]"
输出：false
```

**示例 4：**

```
输入：s = "([)]"
输出：false
```

**示例 5：**

```
输入：s = "{[]}"
输出：true
```

**提示：**

- `1 <= s.length <= 104`
- `s` 仅由括号 `'()[]{}'` 组成

```go
func isValid(s string) bool {
	l := []byte(s)
	stack := []byte{}
	for _, b := range l {
		if b == '(' || b == '[' || b == '{' {
			stack = append(stack, b)
		} else if b == ')' {
			if len(stack) == 0 || stack[len(stack) - 1] != '(' { return false }
			stack = stack[:len(stack) - 1]
		} else if b == ']' {
			if len(stack) == 0 || stack[len(stack) - 1] != '[' { return false }
			stack = stack[:len(stack) - 1]
		} else {
			if len(stack) == 0 || stack[len(stack) - 1] != '{' { return false }
			stack = stack[:len(stack) - 1]
		}
	}
	return len(stack) == 0
}
```



#### [155. 最小栈](https://leetcode-cn.com/problems/min-stack/)

难度简单839收藏分享切换为英文接收动态反馈

设计一个支持 `push` ，`pop` ，`top` 操作，并能在常数时间内检索到最小元素的栈。

- `push(x)` —— 将元素 x 推入栈中。
- `pop()` —— 删除栈顶的元素。
- `top()` —— 获取栈顶元素。
- `getMin()` —— 检索栈中的最小元素。

**示例:**

```
输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

输出：
[null,null,null,null,-3,null,0,-2]

解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
```

**提示：**

- `pop`、`top` 和 `getMin` 操作总是在 **非空栈** 上调用。

```go
// 单调减的栈。
func trap(height []int) int {
	res := 0
	stack := []int{}
	for i:=0; i < len(height); i++ {
		for len(stack) != 0 && height[stack[len(stack) - 1]] < height[i] {
			cur := stack[len(stack) - 1]
			stack = stack[:len(stack) - 1]
			if len(stack) == 0 { break }
			// 计算左右边界
			l, r := stack[len(stack) - 1], i
			// 计算雨滴
			h := min(height[r], height[l]) - height[cur]
			res += (r - l - 1) * h
		}
		stack = append(stack, i)
	}
	return res
}

func min(a, b int) int {
	if a < b { return a }
	return b
}
```



#### [641. 设计循环双端队列](https://leetcode-cn.com/problems/design-circular-deque/)

难度中等76收藏分享切换为英文接收动态反馈

设计实现双端队列。
你的实现需要支持以下操作：

- MyCircularDeque(k)：构造函数,双端队列的大小为k。
- insertFront()：将一个元素添加到双端队列头部。 如果操作成功返回 true。
- insertLast()：将一个元素添加到双端队列尾部。如果操作成功返回 true。
- deleteFront()：从双端队列头部删除一个元素。 如果操作成功返回 true。
- deleteLast()：从双端队列尾部删除一个元素。如果操作成功返回 true。
- getFront()：从双端队列头部获得一个元素。如果双端队列为空，返回 -1。
- getRear()：获得双端队列的最后一个元素。 如果双端队列为空，返回 -1。
- isEmpty()：检查双端队列是否为空。
- isFull()：检查双端队列是否满了。

**示例：**

```
MyCircularDeque circularDeque = new MycircularDeque(3); // 设置容量大小为3
circularDeque.insertLast(1);			        		// 返回 true
circularDeque.insertLast(2);			        		// 返回 true
circularDeque.insertFront(3);			        		// 返回 true
circularDeque.insertFront(4);			        		// 已经满了，返回 false
circularDeque.getRear();  								// 返回 2
circularDeque.isFull();				        			// 返回 true
circularDeque.deleteLast();			        			// 返回 true
circularDeque.insertFront(4);			        		// 返回 true
circularDeque.getFront();								// 返回 4
 
```

**提示：**

- 所有值的范围为 [1, 1000]
- 操作次数的范围为 [1, 1000]
- 请不要使用内置的双端队列库。

```go
type MyCircularDeque struct {
	queue []int
	first int
	rear  int
	size  int
}

/** Initialize your data structure here. Set the size of the deque to be k. */
func Constructor(k int) MyCircularDeque {
	return MyCircularDeque{
		queue: make([]int, k, k),
		first: 0,
		rear:  1,
		size:  0,
	}
}

// 添加时，先添加，再移位
/** Adds an item at the front of Deque. Return true if the operation is successful. */
func (this *MyCircularDeque) InsertFront(value int) bool {
	if this.IsFull() { return false }
	this.queue[this.first] = value
	this.size++
	this.first = (len(this.queue) + this.first-1) % (len(this.queue))
	return true
}

/** Adds an item at the rear of Deque. Return true if the operation is successful. */
func (this *MyCircularDeque) InsertLast(value int) bool {
	if this.IsFull() { return false }
	this.queue[this.rear] = value
	this.size++
	this.rear = (this.rear+1) % (len(this.queue))
	return true
}

// 删除时，先移动索引，再删除
/** Deletes an item from the front of Deque. Return true if the operation is successful. */
func (this *MyCircularDeque) DeleteFront() bool {
	if this.IsEmpty() { return false }
	this.first = (this.first+1) % (len(this.queue))
	this.queue[this.first] = 0
	this.size--
	return true
}

/** Deletes an item from the rear of Deque. Return true if the operation is successful. */
func (this *MyCircularDeque) DeleteLast() bool {
	if this.IsEmpty() { return false }
	this.rear = (len(this.queue)+this.rear-1) % (len(this.queue))
	this.queue[this.rear] = 0
	this.size--
	return true
}

/** Get the front item from the deque. */
func (this *MyCircularDeque) GetFront() int {
	if this.IsEmpty() { return -1 }
	return this.queue[(this.first+1) % (len(this.queue))]
}

/** Get the last item from the deque. */
func (this *MyCircularDeque) GetRear() int {
	if this.IsEmpty() { return -1 }
	return this.queue[(len(this.queue)+this.rear-1) % (len(this.queue))]
}

/** Checks whether the circular deque is empty or not. */
func (this *MyCircularDeque) IsEmpty() bool {
	return this.size == 0
}

/** Checks whether the circular deque is full or not. */
func (this *MyCircularDeque) IsFull() bool {
	return this.size == len(this.queue)

```



#### [84. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)

难度困难1244收藏分享切换为英文接收动态反馈

给定 *n* 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram.png)

以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 `[2,1,5,6,2,3]`。

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram_area.png)

图中阴影部分为所能勾勒出的最大矩形面积，其面积为 `10` 个单位。

**示例:**

```
输入: [2,1,5,6,2,3]
输出: 10
```

```go
// 单调栈，维护一个单调增的栈，用来存放右边界之前的所有值
func largestRectangleArea(heights []int) int {
	heights = append(heights, 0)
	stack := [][]int{{-1, 0}}
	res := 0
	for i:=0; i<len(heights); i++ {
		l, r := i - 1, i - 1
		for heights[i] < stack[len(stack) - 1][1] {
			// -2是为了取上一个栈中前面那个元素的位置，因为上一个位置才是边界。
			l = stack[len(stack) - 2][0]
			res = max(res, stack[len(stack) - 1][1] * (r - l))
			stack = stack[:len(stack) - 1]
		}

		stack = append(stack, []int{i, heights[i]})
	}
	return res
}

func max(a, b int) int {
	if a<b { return b }
	return a
}
```



#### [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)

难度困难2153收藏分享切换为英文接收动态反馈

给定 *n* 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png)

```
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 
```

**示例 2：**

```
输入：height = [4,2,0,3,2,5]
输出：9
```

**提示：**

- `n == height.length`
- `0 <= n <= 3 * 104`
- `0 <= height[i] <= 105`

```go
// 单调减的栈。
func trap(height []int) int {
	res := 0
	stack := []int{}
	for i:=0; i < len(height); i++ {
		for len(stack) != 0 && height[stack[len(stack) - 1]] < height[i] {
			cur := stack[len(stack) - 1]
			stack = stack[:len(stack) - 1]
			if len(stack) == 0 { break }
			// 计算左右边界
			l, r := stack[len(stack) - 1], i
			// 计算雨滴
			h := min(height[r], height[l]) - height[cur]
			res += (r - l - 1) * h
		}
		stack = append(stack, i)
	}
	return res
}

func min(a, b int) int {
	if a < b { return a }
	return b
}
```



#### [239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)

难度困难896收藏分享切换为英文接收动态反馈

给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。

返回滑动窗口中的最大值。

**示例 1：**

```
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

**示例 2：**

```
输入：nums = [1], k = 1
输出：[1]
```

**示例 3：**

```
输入：nums = [1,-1], k = 1
输出：[1,-1]
```

**示例 4：**

```
输入：nums = [9,11], k = 2
输出：[11]
```

**示例 5：**

```
输入：nums = [4,-2], k = 2
输出：[4]
```

**提示：**

- `1 <= nums.length <= 105`
- `-104 <= nums[i] <= 104`
- `1 <= k <= nums.length`

```go
// 维护一个单调减的双端队列，这个队列存可能是最大值的数组下标，这个队列的第一个元素就是最大值下标。
func maxSlidingWindow(nums []int, k int) []int {
	queue := []int{}
	for i:=0; i<k; i++ {
		for len(queue)!=0 && nums[i] >= nums[queue[len(queue)-1]] {
			queue = queue[:len(queue)-1]
		}
		queue = append(queue, i)
	}
	res := []int{nums[queue[0]]}
	for i:=k; i<len(nums); i++ {
		for len(queue)!=0 && nums[i] >= nums[queue[len(queue)-1]] {
			queue = queue[:len(queue)-1]
		}
		queue = append(queue, i)
		// 在这里判断队列第一个元素是否还在窗口里
		for queue[0]+k <= i {
			queue = queue[1:]
		}
		res = append(res, nums[queue[0]])
	}
	return res
}
```



# 四、二叉树

## 1、遍历

#### [144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

难度中等537收藏分享切换为英文接收动态反馈

给你二叉树的根节点 `root` ，返回它节点值的 **前序** 遍历。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg)

```
输入：root = [1,null,2,3]
输出：[1,2,3]
```

**示例 2：**

```
输入：root = []
输出：[]
```

**示例 3：**

```
输入：root = [1]
输出：[1]
```

**示例 4：**

![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_5.jpg)

```
输入：root = [1,2]
输出：[1,2]
```

**示例 5：**

![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_4.jpg)

```
输入：root = [1,null,2]
输出：[1,2]
```

**提示：**

- 树中节点数目在范围 `[0, 100]` 内
- `-100 <= Node.val <= 100`

```go
type TreeNode struct {
	Val int
	Left *TreeNode
	Right *TreeNode
}

// 三种递归写法

func preorderTraversal1(root *TreeNode) (res []int) {
	if root == nil {
		return
	}
	res = append(res, root.Val)
	res = append(res, preorderTraversal1(root.Left)...)
	res = append(res, preorderTraversal1(root.Right)...)
	return
}

var res []int
func preorderTraversal2(root *TreeNode) []int {
	res = []int{}
	dfs(root)
	return res
}
func dfs(root *TreeNode) {
	if root != nil {
		res = append(res, root.Val)
		dfs(root.Left)
		dfs(root.Right)
	}
}

func preorderTraversal3(root *TreeNode) (res []int) {
	var preorder func(*TreeNode)
	preorder = func(node *TreeNode) {
		if node == nil {
			return
		}
		res = append(res, node.Val)
		preorder(node.Left)
		preorder(node.Right)
	}
	preorder(root)
	return
}
```



#### [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

难度中等541收藏分享切换为英文接收动态反馈

给定一个二叉树，返回它的 *后序* 遍历。

**示例:**

```
输入: [1,null,2,3]  
   1
    \
     2
    /
   3 

输出: [3,2,1]
```

```go
func postorderTraversal(root *TreeNode) []int {
	res := []int{}
	if root == nil { return res }
	res = append(res, postorderTraversal(root.Left)...)
	res = append(res, postorderTraversal(root.Right)...)
	res = append(res, root.Val)
	return res
}
```



#### [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

难度中等810收藏分享切换为英文接收动态反馈

给你一个二叉树，请你返回其按 **层序遍历** 得到的节点值。 （即逐层地，从左到右访问所有节点）。

**示例：**
二叉树：`[3,9,20,null,null,15,7]`,

```
    3
   / \
  9  20
    /  \
   15   7
```

返回其层序遍历结果：

```
[
  [3],
  [9,20],
  [15,7]
]
```

```go
// 层序遍历就是BFS，注意保存每层queue的长度，因为queue是变化的，所以不能在for中使用
func levelOrder(root *TreeNode) [][]int {
	var res [][]int
	if root == nil { return res }
	queue := []*TreeNode{root}
	level := 0
	for len(queue) > 0 {
		res = append(res, []int{})
		length := len(queue)
		for i:=0; i<length; i++ {
			node := queue[0]
			queue = queue[1:]
			res[level] = append(res[level], node.Val)
			if node.Left  != nil { queue = append(queue, node.Left) }
			if node.Right != nil { queue = append(queue, node.Right) }
		}
		level++
	}
	return res
}
```



#### [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

难度中等883收藏分享切换为英文接收动态反馈

给定一个二叉树的根节点 `root` ，返回它的 **中序** 遍历。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg)

```
输入：root = [1,null,2,3]
输出：[1,3,2]
```

**示例 2：**

```
输入：root = []
输出：[]
```

**示例 3：**

```
输入：root = [1]
输出：[1]
```

**示例 4：**

![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_5.jpg)

```
输入：root = [1,2]
输出：[2,1]
```

**示例 5：**

![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_4.jpg)

```
输入：root = [1,null,2]
输出：[1,2]
```

**提示：**

- 树中节点数目在范围 `[0, 100]` 内
- `-100 <= Node.val <= 100`

```go
func inorderTraversal(root *TreeNode) []int {
	var res []int
	if root == nil { return res }
	res = append(res, inorderTraversal(root.Left)...)
	res = append(res, root.Val)
	res = append(res, inorderTraversal(root.Right)...)
	return res
}
```



## 2、二叉树属性相关

#### [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

难度简单1294收藏分享切换为英文接收动态反馈

给定一个二叉树，检查它是否是镜像对称的。

例如，二叉树 `[1,2,2,3,4,4,3]` 是对称的。

```
    1
   / \
  2   2
 / \ / \
3  4 4  3
```

但是下面这个 `[1,2,2,null,3,null,3]` 则不是镜像对称的:

```
    1
   / \
  2   2
   \   \
   3    3
```

```go
func isSymmetric(root *TreeNode) bool {
	if root == nil { return true }
	return check(root.Left, root.Right)
}

func check(l *TreeNode, r *TreeNode) bool {
	// 是否对称的几种情况，
	if l == nil && r == nil { return true }
	if l == nil && r != nil { return false }
	if l != nil && r == nil { return false }

	if l.Val != r.Val { return false }
	// 需要递归的是从中间看是否对称，而不是当前节点的左右对称
	return check(l.Left, r.Right) && check(l.Right, r.Left)
}
```



#### [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

难度简单824收藏分享切换为英文接收动态反馈

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

**说明:** 叶子节点是指没有子节点的节点。

**示例：**
给定二叉树 `[3,9,20,null,null,15,7]`，

```
    3
   / \
  9  20
    /  \
   15   7
```

返回它的最大深度 3 。

```go
// 理解求最大深度就是递归的求当前节点max(左子树最大深度，右子树最大深度)+1
func maxDepth(root *TreeNode) int {
	if root == nil { return 0 }

	return max(maxDepth(root.Left), maxDepth(root.Right)) + 1
}

func max(a, b int) int {
	if a > b { return a }
	return b
}
```



#### [111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

难度简单473收藏分享切换为英文接收动态反馈

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

**说明：**叶子节点是指没有子节点的节点。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：2
```

**示例 2：**

```
输入：root = [2,null,3,null,4,null,5,null,6]
输出：5
```

**提示：**

- 树中节点数的范围在 `[0, 105]` 内
- `-1000 <= Node.val <= 1000`

```go
// 与最大深度不同的是，当遇到只有1个子节点，走到那个为nil的分支上时，最大深度会直接算出来然后舍弃掉。
// 但是最小深度，只有1个分支时不是最低点，需要左右两个都是空才是。所以对1个分支进行了单独处理。
func minDepth(root *TreeNode) int {
	if root == nil { return 0 }
	if root.Left != nil && root.Right == nil { return minDepth(root.Left) + 1 }
	if root.Left == nil && root.Right != nil { return minDepth(root.Right) + 1 }
	return min(minDepth(root.Left), minDepth(root.Right)) + 1
}

func min(a, b int) int {
	if a < b { return a }
	return b
}
```



#### [222. 完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)

难度中等454收藏分享切换为英文接收动态反馈

给你一棵 **完全二叉树** 的根节点 `root` ，求出该树的节点个数。

[完全二叉树](https://baike.baidu.com/item/完全二叉树/7773232?fr=aladdin) 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 `h` 层，则该层包含 `1~ 2h` 个节点。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/14/complete.jpg)

```
输入：root = [1,2,3,4,5,6]
输出：6
```

**示例 2：**

```
输入：root = []
输出：0
```

**示例 3：**

```
输入：root = [1]
输出：1
```

**提示：**

- 树中节点的数目范围是`[0, 5 * 104]`
- `0 <= Node.val <= 5 * 104`
- 题目数据保证输入的树是 **完全二叉树**

```go
// 由于是完全二叉树，直接数就行；另一种方法是二分查找
func countNodes(root *TreeNode) int {
	if root==nil { return 0 }
	return countNodes(root.Left) + countNodes(root.Right) + 1
}
```



#### [110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)

难度简单637收藏分享切换为英文接收动态反馈

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

> 一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过 1 。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：true
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg)

```
输入：root = [1,2,2,3,3,null,null,4,4]
输出：false
```

**示例 3：**

```
输入：root = []
输出：true
```

**提示：**

- 树中的节点数在范围 `[0, 5000]` 内
- `-104 <= Node.val <= 104`

```go
func isBalanced(root *TreeNode) bool {
	return height(root) >= 0
}

// 所谓的自底向上递归。
// 但是理解成，只需要求出左子树高度和右子树高度，保证差的绝对值<=1，就返回高度。
func height(node *TreeNode) int {
	if node == nil { return 0 }

	leftHeight := height(node.Left)
	rightHeight := height(node.Right)

	if leftHeight == -1 || rightHeight == -1 || abs(leftHeight - rightHeight) > 1 { return -1 }
	return max(leftHeight, rightHeight) + 1
}

func max(a, b int) int {
	if a > b { return a}
	return b
}

func abs(x int) int {
	if x < 0 { return -x }
	return x
}
```



#### [257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)

难度简单465收藏分享切换为英文接收动态反馈

给定一个二叉树，返回所有从根节点到叶子节点的路径。

**说明:** 叶子节点是指没有子节点的节点。

**示例:**

```
输入:

   1
 /   \
2     3
 \
  5

输出: ["1->2->5", "1->3"]

解释: 所有根节点到叶子节点的路径为: 1->2->5, 1->3
```

```go
import "strconv"

func binaryTreePaths(root *TreeNode) []string {
	res := []string{}
	buildPath(root, "", &res)
	return res
}

// 标准的递归写法：
func buildPath(node *TreeNode, path string, res *[]string) {
	// 1、递归终止条件
	if node == nil { return }
	if node.Left == nil && node.Right == nil {
		path += strconv.Itoa(node.Val)
		*res = append(*res, path)
		return
	}
	// 2、处理当前层
	path += strconv.Itoa(node.Val) + "->"
	// 3、下探到下一层
	buildPath(node.Left, path, res)
	buildPath(node.Right, path, res)
}
```



#### [404. 左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/)

难度简单296收藏分享切换为英文接收动态反馈

计算给定二叉树的所有左叶子之和。

**示例：**

```
    3
   / \
  9  20
    /  \
   15   7

在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24
```

```go
func sumOfLeftLeaves(root *TreeNode) int {
	res := 0
	dfs(root, &res, false)
	return res
}
// 增加1个标志位表示左子树，然后用左右节点为空筛选叶子
func dfs(node *TreeNode, res *int, flag bool) {
	if node == nil { return }
	if flag && (node.Left == nil && node.Right == nil) { *res += node.Val }

	dfs(node.Left, res, true)
	dfs(node.Right, res, false)
}
```



#### [513. 找树左下角的值](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)

难度中等161收藏分享切换为英文接收动态反馈

给定一个二叉树，在树的最后一行找到最左边的值。

**示例 1:**

```
输入:

    2
   / \
  1   3

输出:
1
```

**示例 2:**

```
输入:

        1
       / \
      2   3
     /   / \
    4   5   6
       /
      7

输出:
7
```

**注意:** 您可以假设树（即给定的根节点）不为 **NULL**。

```go
// BFS
func findBottomLeftValue(root *TreeNode) int {
	queue := []*TreeNode{}
	if root != nil { queue = append(queue, root) }
	result := 0
	for len(queue) > 0 {
		size := len(queue)
		for i:=0; i<size; i++ {
			node := queue[0]
			queue = queue[1:]
			if i == 0 { result = node.Val }
			if node.Left != nil { queue = append(queue, node.Left) }
			if node.Right != nil {  queue = append(queue, node.Right) }
		}
	}
	return result
}
```



#### [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)

难度简单543收藏分享切换为英文接收动态反馈

给你二叉树的根节点 `root` 和一个表示目标和的整数 `targetSum` ，判断该树中是否存在 **根节点到叶子节点** 的路径，这条路径上所有节点值相加等于目标和 `targetSum` 。

**叶子节点** 是指没有子节点的节点。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg)

```
输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
输出：true
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg)

```
输入：root = [1,2,3], targetSum = 5
输出：false
```

**示例 3：**

```
输入：root = [1,2], targetSum = 0
输出：false
```

**提示：**

- 树中节点的数目在范围 `[0, 5000]` 内
- `-1000 <= Node.val <= 1000`
- `-1000 <= targetSum <= 1000`

```go
// 递归的模板
func hasPathSum(root *TreeNode, targetSum int) bool {
	// 1、递归终止条件
	if root == nil { return false }
	// 2、当前层的处理，也可以是第二个终止条件，
	if root.Left == nil && root.Right == nil { return targetSum == root.Val }

	// 3、递归到下一层。
	return hasPathSum(root.Left, targetSum - root.Val) || hasPathSum(root.Right, targetSum - root.Val)
}
```



## 3、二叉树的构造与修改

#### [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

难度简单788收藏分享切换为英文接收动态反馈

翻转一棵二叉树。

**示例：**

输入：

```
     4
   /   \
  2     7
 / \   / \
1   3 6   9
```

输出：

```
     4
   /   \
  7     2
 / \   / \
9   6 3   1
```

```go
func invertTree(root *TreeNode) *TreeNode {
	invert(root)
	return root
}

// 所有节点的左右节点互换，直接递归模板。
func invert(node *TreeNode) {
	if node == nil { return }
	node.Left, node.Right = node.Right, node.Left
	invert(node.Left)
	invert(node.Right)
}
```



#### [617. 合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/)

难度简单639收藏分享切换为英文接收动态反馈

给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。

你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则**不为** NULL 的节点将直接作为新二叉树的节点。

**示例 1:**

```
输入: 
	Tree 1                     Tree 2                  
          1                         2                             
         / \                       / \                            
        3   2                     1   3                        
       /                           \   \                      
      5                             4   7                  
输出: 
合并后的树:
	     3
	    / \
	   4   5
	  / \   \ 
	 5   4   7
```

**注意:** 合并必须从两个树的根节点开始。

```go
// 递归模板
func mergeTrees(root1 *TreeNode, root2 *TreeNode) *TreeNode {
	if root1 == nil { return root2 }
	if root2 == nil { return root1 }

	root1.Val += root2.Val

	root1.Left = mergeTrees(root1.Left, root2.Left)
	root1.Right = mergeTrees(root1.Right, root2.Right)

	return root1
}
```



#### [106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

难度中等465收藏分享切换为英文接收动态反馈

根据一棵树的中序遍历与后序遍历构造二叉树。

**注意:**
你可以假设树中没有重复的元素。

例如，给出

```
中序遍历 inorder = [9,3,15,20,7]
后序遍历 postorder = [9,15,7,20,3]
```

返回如下的二叉树：

```
    3
   / \
  9  20
    /  \
   15   7
```





#### [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

难度中等936收藏分享切换为英文接收动态反馈

根据一棵树的前序遍历与中序遍历构造二叉树。

**注意:**
你可以假设树中没有重复的元素。

例如，给出

```
前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
```

返回如下的二叉树：

```
    3
   / \
  9  20
    /  \
   15   7
```





#### [654. 最大二叉树](https://leetcode-cn.com/problems/maximum-binary-tree/)

难度中等257收藏分享切换为英文接收动态反馈

给定一个不含重复元素的整数数组 `nums` 。一个以此数组直接递归构建的 **最大二叉树** 定义如下：

1. 二叉树的根是数组 `nums` 中的最大元素。
2. 左子树是通过数组中 **最大值左边部分** 递归构造出的最大二叉树。
3. 右子树是通过数组中 **最大值右边部分** 递归构造出的最大二叉树。

返回有给定数组 `nums` 构建的 **最大二叉树** 。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/12/24/tree1.jpg)

```
输入：nums = [3,2,1,6,0,5]
输出：[6,3,5,null,2,0,null,null,1]
解释：递归调用如下所示：
- [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。
    - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。
        - 空数组，无子节点。
        - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。
            - 空数组，无子节点。
            - 只有一个元素，所以子节点是一个值为 1 的节点。
    - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。
        - 只有一个元素，所以子节点是一个值为 0 的节点。
        - 空数组，无子节点。
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/12/24/tree2.jpg)

```
输入：nums = [3,2,1]
输出：[3,null,2,null,1]
```

**提示：**

- `1 <= nums.length <= 1000`
- `0 <= nums[i] <= 1000`
- `nums` 中的所有整数 **互不相同**





#### [297. 二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)

难度困难510收藏分享切换为英文接收动态反馈

序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。

请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。

**提示:** 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 [LeetCode 序列化二叉树的格式](https://leetcode-cn.com/faq/#binary-tree)。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg)

```
输入：root = [1,2,3,null,null,4,5]
输出：[1,2,3,null,null,4,5]
```

**示例 2：**

```
输入：root = []
输出：[]
```

**示例 3：**

```
输入：root = [1]
输出：[1]
```

**示例 4：**

```
输入：root = [1,2]
输出：[1,2]
```

**提示：**

- 树中结点数在范围 `[0, 104]` 内
- `-1000 <= Node.val <= 1000`





## 4、公共祖先问题

#### [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

难度中等1001收藏分享切换为英文接收动态反馈

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

**示例 1：**

![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出：5
解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
```

**示例 3：**

```
输入：root = [1,2], p = 1, q = 2
输出：1
```

**提示：**

- 树中节点数目在范围 `[2, 105]` 内。
- `-109 <= Node.val <= 109`
- 所有 `Node.val` `互不相同` 。
- `p != q`
- `p` 和 `q` 均存在于给定的二叉树中。

```go
// 自底向上传结果。
func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {
	// 终止条件有两个，1个是空节点时，2是当root走到pq时
	if root == nil { return nil }
	if root.Val == p.Val || root.Val == q.Val { return root }

	// 直接下探到下一层，得到在左子树和右子树中最近公共祖先
	l := lowestCommonAncestor(root.Left, p, q)
	r := lowestCommonAncestor(root.Right, p, q)

	// 这里是求这个公共祖先，要联想到上面的终止条件：
	// 1、相等也终止，表示lr就是pq，root就是结果
	// 2、一边为空表示，另一边一定是结果。
	if l != nil && r != nil { return root }
	if l == nil && r != nil { return r }
	return l
}
```



#### [235. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)

难度简单549收藏分享切换为英文接收动态反馈

给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png)

**示例 1:**

```
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
输出: 6 
解释: 节点 2 和节点 8 的最近公共祖先是 6。
```

**示例 2:**

```
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
输出: 2
解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。
```

**说明:**

- 所有节点的值都是唯一的。
- p、q 为不同节点且均存在于给定的二叉搜索树中。

```go
// 二叉搜索树的性质，左子树都小于父，右子树都大于父。
func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {
	res := root
	for {
		if res.Val > q.Val && res.Val > p.Val {
			res = res.Left
		} else if res.Val < q.Val && res.Val < p.Val {
			res = res.Right
		} else { return res }
	}
}
```



## 5、二叉搜索树

#### [700. 二叉搜索树中的搜索](https://leetcode-cn.com/problems/search-in-a-binary-search-tree/)

难度简单116收藏分享切换为英文接收动态反馈

给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。

例如，

```
给定二叉搜索树:

        4
       / \
      2   7
     / \
    1   3

和值: 2
```

你应该返回如下子树:

```
      2     
     / \   
    1   3
```

在上述示例中，如果要找的值是 `5`，但因为没有节点值为 `5`，我们应该返回 `NULL`。

```go
// 一个简单的递归
func searchBST(root *TreeNode, val int) *TreeNode {
	if root == nil || val == root.Val {
		return root
	} else if val < root.Val {
		return searchBST(root.Left, val)
	} else {
		return searchBST(root.Right, val)
	}
}
```



#### [98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

难度中等962收藏分享切换为英文接收动态反馈

给定一个二叉树，判断其是否是一个有效的二叉搜索树。

假设一个二叉搜索树具有如下特征：

- 节点的左子树只包含**小于**当前节点的数。
- 节点的右子树只包含**大于**当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

**示例 1:**

```
输入:
    2
   / \
  1   3
输出: true
```

**示例 2:**

```
输入:
    5
   / \
  1   4
     / \
    3   6
输出: false
解释: 输入为: [5,1,4,null,null,3,6]。
     根节点的值为 5 ，但是其右子节点值为 4 。
```

```go
func isValidBST(root *TreeNode) bool {
	return helper(root, math.MinInt64, math.MaxInt64)
}

// 递归的思路，
func helper(node *TreeNode, min, max int) bool {
	// 1、两个终止条件，如果遍历结束，就返回true，说明遍历的部分都满足
	// 2、当遇到不满足条件的直接返回false
	if node == nil { return true }
	if node.Val <= min || node.Val >= max { return false }

	// 结果就是左子树满足条件&&右子树满足条件，计算左子树就是有最大值了，计算右子树就是有最小值了。
	return helper(node.Left, min, node.Val) && helper(node.Right, node.Val, max)
}
```



#### [530. 二叉搜索树的最小绝对差](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/)

难度简单235收藏分享切换为英文接收动态反馈

给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。

**示例：**

```
输入：

   1
    \
     3
    /
   2

输出：
1

解释：
最小绝对差为 1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。
```

**提示：**

- 树中至少有 2 个节点。

```go
// 1、用到中序遍历，因为中序遍历后是有序的，最小差一定是有序数组两个相邻元素的差。
func getMinimumDifference(root *TreeNode) int {
	res, pre := math.MaxInt64, -1
	dfs(root, &res, &pre)
	return res
}

func dfs(node *TreeNode, res, pre *int) {
	if node == nil { return }

	dfs(node.Left, res, pre)

	// 计算最小值，
	if *pre != -1 && node.Val-*pre < *res {
		*res = node.Val - *pre
	}
	*pre = node.Val

	dfs(node.Right, res, pre)
}
```



#### [501. 二叉搜索树中的众数](https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/)

难度简单281收藏分享切换为英文接收动态反馈

给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。

假定 BST 有如下定义：

- 结点左子树中所含结点的值小于等于当前结点的值
- 结点右子树中所含结点的值大于等于当前结点的值
- 左子树和右子树都是二叉搜索树

例如：
给定 BST `[1,null,2,2]`,

```
   1
    \
     2
    /
   2
```

`返回[2]`.

**提示**：如果众数超过1个，不需考虑输出顺序

```go
// 一样使用中序遍历，但是传入的参数有点多，所以使用了将函数写成变量的方式。
func findMode(root *TreeNode) []int {
	var res []int
	var cnt int
	var maxCnt int
	var preNode *TreeNode
	var dfs func(*TreeNode)
	dfs = func(node *TreeNode) {
		if node == nil { return }

		dfs(node.Left)


		if preNode == nil {
			// preNode还没有值时候
			cnt = 1
		} else if preNode.Val == node.Val {
			// 相等就+1
			cnt++
		} else {
			// 不等就回到1
			cnt = 1
		}
		preNode = node

		if cnt == maxCnt {
			// 当前数和最大数一样，结果中加一个，
			res = append(res, node.Val)
		}
		if cnt > maxCnt {
			// 当前数大，就清空res，把新的结果放进去
			maxCnt = cnt
			res = []int{node.Val}
		}

		dfs(node.Right)
	}

	dfs(root)
	return res
}
```



#### [538. 把二叉搜索树转换为累加树](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)

难度中等492收藏分享切换为英文接收动态反馈

给出二叉 **搜索** 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 `node` 的新值等于原树中大于或等于 `node.val` 的值之和。

提醒一下，二叉搜索树满足下列约束条件：

- 节点的左子树仅包含键 **小于** 节点键的节点。
- 节点的右子树仅包含键 **大于** 节点键的节点。
- 左右子树也必须是二叉搜索树。

**示例 1：**

**![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/05/03/tree.png)**

```
输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]
```

**示例 2：**

```
输入：root = [0,null,1]
输出：[1,null,1]
```

**示例 3：**

```
输入：root = [1,0,2]
输出：[3,3,2]
```

**示例 4：**

```
输入：root = [3,2,4,1]
输出：[7,9,4,10]
```

**提示：**

- 树中的节点数介于 `0` 和 `104` 之间。
- 每个节点的值介于 `-104` 和 `104` 之间。
- 树中的所有值 **互不相同** 。
- 给定的树为二叉搜索树。

```go
// 反向中序遍历，新二叉树每个节点的val是比他大节点的和。反序求和：
// 二叉搜索树想到中序遍历，因为是有序的。
func convertBST(root *TreeNode) *TreeNode {
	sum := 0
	var dfs func(*TreeNode)
	dfs = func(node *TreeNode) {
		if node == nil { return }
		dfs(node.Right)
		sum += node.Val
		node.Val = sum
		dfs(node.Left)
	}
	dfs(root)
	return root
}
```



#### [701. 二叉搜索树中的插入操作](https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/)

难度中等164收藏分享切换为英文接收动态反馈

给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 **保证** ，新值和原始二叉搜索树中的任意节点值都不同。

**注意**，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 **任意有效的结果** 。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/05/insertbst.jpg)

```
输入：root = [4,2,7,1,3], val = 5
输出：[4,2,7,1,3,5]
解释：另一个满足题目要求可以通过的树是：
```

**示例 2：**

```
输入：root = [40,20,60,10,30,50,70], val = 25
输出：[40,20,60,10,30,50,70,null,null,25]
```

**示例 3：**

```
输入：root = [4,2,7,1,3,null,null,null,null,null,null], val = 5
输出：[4,2,7,1,3,5]
```

**提示：**

- 给定的树上的节点数介于 `0` 和 `10^4` 之间
- 每个节点都有一个唯一整数值，取值范围从 `0` 到 `10^8`
- `-10^8 <= val <= 10^8`
- 新值和原始二叉搜索树中的任意节点值都不同

```go
// 递归，直接插到叶子节点上去。
func insertIntoBST(root *TreeNode, val int) *TreeNode {
	if root == nil { return &TreeNode{Val: val} }
	if val < root.Val {
		root.Left = insertIntoBST(root.Left, val)
	} else {
		root.Right = insertIntoBST(root.Right, val)
	}
	return root
}
```



#### [450. 删除二叉搜索树中的节点](https://leetcode-cn.com/problems/delete-node-in-a-bst/)

难度中等412收藏分享切换为英文接收动态反馈

给定一个二叉搜索树的根节点 **root** 和一个值 **key**，删除二叉搜索树中的 **key** 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。

一般来说，删除节点可分为两个步骤：

1. 首先找到需要删除的节点；
2. 如果找到了，删除它。

**说明：** 要求算法时间复杂度为 O(h)，h 为树的高度。

**示例:**

```
root = [5,3,6,2,4,null,7]
key = 3

    5
   / \
  3   6
 / \   \
2   4   7

给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。

一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。

    5
   / \
  4   6
 /     \
2       7

另一个正确答案是 [5,2,6,null,4,null,7]。

    5
   / \
  2   6
   \   \
    4   7
```

```go
func deleteNode(root *TreeNode, key int) *TreeNode {
	//总共3种情况
	//1、node只有左树，保留左
	//1、node只有右树，保留右
	//1、node有左树&右树，保留右和左
	if root == nil { return root }
	if root.Val < key{
		root.Right = deleteNode(root.Right,key)
	}else if root.Val > key{
		root.Left = deleteNode(root.Left,key)
	}else{
		// 这里的返回值，如果是根节点就直接返回，非根节点返回到上面
		if root.Right == nil{
			root = root.Left
		}else if root.Left == nil{
			root = root.Right
		}else{
			node := root.Right

			for node.Left!=nil{
				node = node.Left
			}
			node.Left = root.Left
			root = root.Right
		}
	}
	return root
}
```



#### [669. 修剪二叉搜索树](https://leetcode-cn.com/problems/trim-a-binary-search-tree/)

难度中等359

给你二叉搜索树的根节点 `root` ，同时给定最小边界`low` 和最大边界 `high`。通过修剪二叉搜索树，使得所有节点的值在`[low, high]`中。修剪树不应该改变保留在树中的元素的相对结构（即，如果没有被移除，原有的父代子代关系都应当保留）。 可以证明，存在唯一的答案。

所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/09/09/trim1.jpg)

```
输入：root = [1,0,2], low = 1, high = 2
输出：[1,null,2]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/09/09/trim2.jpg)

```
输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3
输出：[3,2,null,1]
```

**示例 3：**

```
输入：root = [1], low = 1, high = 2
输出：[1]
```

**示例 4：**

```
输入：root = [1,null,2], low = 1, high = 3
输出：[1,null,2]
```

**示例 5：**

```
输入：root = [1,null,2], low = 2, high = 4
输出：[2]
```

**提示：**

- 树中节点数在范围 `[1, 104]` 内
- `0 <= Node.val <= 104`
- 树中每个节点的值都是唯一的
- 题目数据保证输入是一棵有效的二叉搜索树
- `0 <= low <= high <= 104`

```go
// 注意点：当前val<low时，需要保留右子树；当前val>high时，需要保留左子树
func trimBST(root *TreeNode, low int, high int) *TreeNode {
	if root == nil { return root }
	// 这行才是处理当前层。
	if root.Val > high { return trimBST(root.Left, low, high) }
	if root.Val < low  { return trimBST(root.Right, low, high) }

	root.Left = trimBST(root.Left, low, high)
	root.Right = trimBST(root.Right, low, high)
	return root
}
```



#### [108.将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)

难度简单725

给你一个整数数组 `nums` ，其中元素已经按 **升序** 排列，请你将其转换为一棵 **高度平衡** 二叉搜索树。

**高度平衡** 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg)

```
输入：nums = [-10,-3,0,5,9]
输出：[0,-3,9,-10,null,5]
解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/02/18/btree.jpg)

```
输入：nums = [1,3]
输出：[3,1]
解释：[1,3] 和 [3,1] 都是高度平衡二叉搜索树。
```

**提示：**

- `1 <= nums.length <= 104`
- `-104 <= nums[i] <= 104`
- `nums` 按 **严格递增** 顺序排列

```go
// 平衡二叉树，直接从数组中间开始分别向左，向右遍历
func sortedArrayToBST(nums []int) *TreeNode {
	return helper(nums, 0, len(nums) - 1)
}

func helper(nums []int, l, r int) *TreeNode {
	if l > r { return nil }

	m := l + (r - l) / 2
	node := &TreeNode{Val: nums[m]}
	node.Left = helper(nums, l, m - 1)
	node.Right = helper(nums, m + 1, r)
	return node
}
```



#### [968. 监控二叉树](https://leetcode-cn.com/problems/binary-tree-cameras/)

难度困难267

给定一个二叉树，我们在树的节点上安装摄像头。

节点上的每个摄影头都可以监视**其父对象、自身及其直接子对象。**

计算监控树的所有节点所需的最小摄像头数量。

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_01.png)

```
输入：[0,0,null,0,0]
输出：1
解释：如图所示，一台摄像头足以监控所有节点。
```

**示例 2：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_02.png)

```
输入：[0,0,null,0,null,0,null,null,0]
输出：2
解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。
```

**提示：**

1. 给定树的节点数的范围是 `[1, 1000]`。
2. 每个节点的值都是 0。





# 五、回溯

和大佬学习的回溯模板：

```c
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```



## 1、组合问题

#### [77. 组合](https://leetcode-cn.com/problems/combinations/)

难度中等525

给定两个整数 *n* 和 *k*，返回 1 ... *n* 中所有可能的 *k* 个数的组合。

**示例:**

```
输入: n = 4, k = 2
输出:
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
```

题解链接：https://leetcode-cn.com/problems/combinations/solution/77-zu-he-hui-su-fa-jing-dian-ti-mu-by-carlsun-2/

```go
func combine(n int, k int) [][]int {
	var res  [][]int
	var temp []int
	var helper func(int)
	helper = func(idx int) {
		if len(temp) == k {
			t := make([]int, len(temp))
			copy(t, temp)
			res = append(res, t)
			return
		}
		// n - (k - len(temp)) + 1用来剪枝；普通的回溯法是：i <= n
		for i := idx; i <= n - (k - len(temp)) + 1; i++ {
			temp = append(temp, i)
			helper(i + 1)
			temp = temp[:len(temp) - 1]
		}
	}

	helper(1)
	return res
}
```



#### [17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

难度中等1187

给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。答案可以按 **任意顺序** 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/17_telephone_keypad.png)

 

**示例 1：**

```
输入：digits = "23"
输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
```

**示例 2：**

```
输入：digits = ""
输出：[]
```

**示例 3：**

```
输入：digits = "2"
输出：["a","b","c"]
```

**提示：**

- `0 <= digits.length <= 4`
- `digits[i]` 是范围 `['2', '9']` 的一个数字。

```go
// 与上一个差不多
var phoneMap map[byte]string = map[byte]string{
    '2': "abc",
    '3': "def",
    '4': "ghi",
    '5': "jkl",
    '6': "mno",
    '7': "pqrs",
    '8': "tuv",
    '9': "wxyz",
}

func letterCombinations(digits string) []string {
    if len(digits) == 0 { return []string{} }

    digitsByte := []byte(digits)
    var res  []string
	var temp []byte
	var helper func(int)
	// 这次idx可以看成是level了，也就是digits的第几位
	helper = func(idx int) {
		if len(temp) == len(digits) {
			t := make([]byte, len(temp))
			copy(t, temp)
			res = append(res, string(t))
			return
		}
        letters := []byte(phoneMap[digitsByte[idx]])
        // 因为要遍历letters中的所有元素，所以从0开始
		for i := 0; i < len(letters); i++ {
			temp = append(temp, letters[i])
			helper(idx + 1)
			temp = temp[:len(temp) - 1]
		}
	}

	helper(0)
	return res
}
```

#### [39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)

难度中等1225

给定一个**无重复元素**的数组 `candidates` 和一个目标数 `target` ，找出 `candidates` 中所有可以使数字和为 `target` 的组合。

`candidates` 中的数字可以无限制重复被选取。

**说明：**

- 所有数字（包括 `target`）都是正整数。
- 解集不能包含重复的组合。 

**示例 1：**

```
输入：candidates = [2,3,6,7], target = 7,
所求解集为：
[
  [7],
  [2,2,3]
]
```

**示例 2：**

```
输入：candidates = [2,3,5], target = 8,
所求解集为：
[
  [2,2,2,2],
  [2,3,3],
  [3,5]
]
```

**提示：**

- `1 <= candidates.length <= 30`
- `1 <= candidates[i] <= 200`
- `candidate` 中的每个元素都是独一无二的。
- `1 <= target <= 500`

```go
func combinationSum(candidates []int, target int) [][]int {
	n := len(candidates)
	sum := 0
	var res  [][]int
	var temp []int
	var helper func(int)
	helper = func(idx int) {
		if sum > target { return }
		if sum == target {
			t := make([]int, len(temp))
			copy(t, temp)
			res = append(res, t)
			return
		}
		// sum + candidates[i] <= target 可以用于剪枝
		for i := idx; i < n && sum + candidates[i] <= target; i++ {
			sum += candidates[i]
			temp = append(temp, candidates[i])
			helper(i)				// 数字可以重复，所以不需要+1
			sum -= candidates[i]
			temp = temp[:len(temp) - 1]
		}
	}

	helper(0)
	return res
}
```

#### [40. 组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/)

难度中等528

给定一个数组 `candidates` 和一个目标数 `target` ，找出 `candidates` 中所有可以使数字和为 `target` 的组合。

`candidates` 中的每个数字在每个组合中只能使用一次。

**说明：**

- 所有数字（包括目标数）都是正整数。
- 解集不能包含重复的组合。 

**示例 1:**

```
输入: candidates = [10,1,2,7,6,1,5], target = 8,
所求解集为:
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]
```

**示例 2:**

```
输入: candidates = [2,5,2,1,2], target = 5,
所求解集为:
[
  [1,2,2],
  [5]
]
```

```go
func combinationSum2(candidates []int, target int) [][]int {
	n := len(candidates)
	sum := 0
	var res  [][]int
	var temp []int
	var helper func(int)
	helper = func(idx int) {
		if sum > target { return }
		if sum == target {
			t := make([]int, len(temp))
			copy(t, temp)
			res = append(res, t)
			return
		}
		for i := idx; i < n; i++ {
			// 排序后避免重复，需要当前元素和他前一个元素不等就行了
			if i - 1 >= idx && candidates[i] == candidates[i-1] { continue }

			sum += candidates[i]
			temp = append(temp, candidates[i])
			helper(i+1)				// 数字可以重复，所以不需要+1
			sum -= candidates[i]
			temp = temp[:len(temp) - 1]
		}
	}
	sort.Ints(candidates)
	helper(0)
	return res
}
```

#### [216. 组合总和 III](https://leetcode-cn.com/problems/combination-sum-iii/)

难度中等280

找出所有相加之和为 ***n*** 的 ***k\*** 个数的组合***。\***组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。

**说明：**

- 所有数字都是正整数。
- 解集不能包含重复的组合。 

**示例 1:**

```
输入: k = 3, n = 7
输出: [[1,2,4]]
```

**示例 2:**

```
输入: k = 3, n = 9
输出: [[1,2,6], [1,3,5], [2,3,4]]
```

```go
func combinationSum3(k int, n int) [][]int {
    sum := 0
	var res  [][]int
	var temp []int
	var helper func(int)
	helper = func(idx int) {
        if len(temp) > k || sum > n { return }
		if len(temp) == k && sum == n {
            t := make([]int, k)
            copy(t, temp)
            res = append(res, t)
            return
        }

        for i := idx; i <= 9; i++ {
            sum += i
            temp = append(temp, i)
            helper(i + 1)
            sum -= i
            temp = temp[:len(temp) - 1]
        }
	}
	helper(1)
	return res
}
```

总结一下三个组合总和问题：

- 排序的重要性：在去重的问题中，需要排序，排好序的数组更容易去重；
- idx的理解：idx就是下一层的起始点。比如1允许重复，起始点和当前层一样；后面不允许重复，起始点就需要后移一位
- 理解for循环中的内容：求和时需要加数字，当当前数字试验完成，就需要把这个数减回去。

#### [22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

难度中等1644

数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。

**示例 1：**

```
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
```

**示例 2：**

```
输入：n = 1
输出：["()"]
```

**提示：**

- `1 <= n <= 8`

```go
func generateParenthesis(n int) []string {
	var res []string
	var dfs func(temp []byte, l, r, target int)
	dfs = func(temp []byte, l, r, target int) {
		if l == target && r == target {
			res = append(res, string(temp))
			return
		}

		if l < target {
			dfs(append(temp, '('), l + 1, r, target)
		}
		if r < l {
			dfs(append(temp, ')'), l, r + 1, target)
		}
	}
	dfs([]byte{}, 0, 0, n)
	return res
}
```



## 2、分割问题

#### [93. 复原 IP 地址](https://leetcode-cn.com/problems/restore-ip-addresses/)

难度中等527

给定一个只包含数字的字符串，用以表示一个 IP 地址，返回所有可能从 `s` 获得的 **有效 IP 地址** 。你可以按任何顺序返回答案。

**有效 IP 地址** 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 `0`），整数之间用 `'.'` 分隔。

例如："0.1.2.201" 和 "192.168.1.1" 是 **有效** IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 **无效** IP 地址。

**示例 1：**

```
输入：s = "25525511135"
输出：["255.255.11.135","255.255.111.35"]
```

**示例 2：**

```
输入：s = "0000"
输出：["0.0.0.0"]
```

**示例 3：**

```
输入：s = "1111"
输出：["1.1.1.1"]
```

**示例 4：**

```
输入：s = "010010"
输出：["0.10.0.10","0.100.1.0"]
```

**示例 5：**

```
输入：s = "101023"
输出：["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"]
```

**提示：**

- `0 <= s.length <= 3000`
- `s` 仅由数字组成

```go
func restoreIpAddresses(s string) []string {
	var res []string
	var temp []string
	var dfs func(idx int)
	dfs = func(idx int) {
		// 终止条件是temp有4段，并且idx也到了s的结尾
		if len(temp) == 4 && idx == len(s) {
			res = append(res, strings.Join(temp, "."))
			return
		}
		if len(temp) == 4 && idx < len(s) {
			return
		}
		for l := 1; l <= 3; l++ {
			// 有几种情况是需要直接返回：1、idx+l超范围；2、当前段开头为0
			if idx + l - 1 >= len(s) { return }
			if l != 1 && s[idx] == '0' { return }
			str := s[idx : l + idx]
			n, _ := strconv.Atoi(str);
			if n > 255 { return }
			temp = append(temp, str)
			dfs(idx + l)
			temp = temp[:len(temp) - 1]
		}
	}

	dfs(0)
	return res
}
```



#### [131. 分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/)

难度中等655

给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是 **回文串** 。返回 `s` 所有可能的分割方案。

**回文串** 是正着读和反着读都一样的字符串。

**示例 1：**

```
输入：s = "aab"
输出：[["a","a","b"],["aa","b"]]
```

**示例 2：**

```
输入：s = "a"
输出：[["a"]]
```

**提示：**

- `1 <= s.length <= 16`
- `s` 仅由小写英文字母组成

```go
func partition(s string) [][]string {
	var res [][]string
	var temp []string
	var palindrome func(str string, l, r int) bool
	var dfs func(idx int)
	palindrome = func(str string, l, r int) bool {
		for l < r {
			if str[l] == str[r] {
				l++
				r--
			} else {
				return false
			}
		}
		return true
	}
	dfs = func(idx int) {
        // 当start指针越界了，一直切出回文才走到这，将当前的部分解temp加入解集res
		if idx == len(s) {
			t := make([]string, len(temp))
			copy(t, temp)
			res = append(res, t)
			return
		}
        // 枚举出当前的所有选项，从索引idx到末尾索引
		for i := idx; i < len(s); i++ {
            // 当前选择i，如果 idx 到 i 是回文串，就添加到temp
			if palindrome(s, idx, i) {
				temp = append(temp, s[idx : i+1])
                // 基于这个选择，继续往下递归，继续
				dfs(i + 1)
                // 上面递归结束了，撤销当前选择i，去下一轮迭代
				temp = temp[: len(temp) - 1]
			}
		}
	}

	dfs(0)
	return res
}
```



## 3、子集问题

#### [169. 多数元素](https://leetcode-cn.com/problems/majority-element/)

难度简单920

给定一个大小为 *n* 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 **大于** `⌊ n/2 ⌋` 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

**示例 1：**

```
输入：[3,2,3]
输出：3
```

**示例 2：**

```
输入：[2,2,1,1,1,2,2]
输出：2
```

**进阶：**

- 尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。

```go
func majorityElement(nums []int) int {
	var count func(num, l, r int) int			// 求num在l-r范围内的数量
	var majorityElementRec func(l, r int) int	// 求最多的num
	count = func(num, l, r int) int {
		var c int
		for i := l; i <= r; i++ {
			if nums[i] == num { c++ }
		}
		return c
	}
	// 最多的数一定是在左半最多或者右半最多。
	majorityElementRec = func(l, r int) int {
		if l == r {
			return nums[l]
		}

		m := (r - l) / 2 + l
		// 求左半最多和右半最多，然后返回最多的那个数。
		left := majorityElementRec(l, m)
		right := majorityElementRec(m + 1, r)

		if left == right { return left }

		leftCount := count(left, l, m)
		rightCount := count(right, m + 1, r)
		if leftCount > rightCount { return left }
		return right
	}
	return majorityElementRec(0, len(nums) - 1)
}
```



#### [78. 子集](https://leetcode-cn.com/problems/subsets/)

难度中等1064

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。

**示例 1：**

```
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```

**示例 2：**

```
输入：nums = [0]
输出：[[],[0]]
```

**提示：**

- `1 <= nums.length <= 10`
- `-10 <= nums[i] <= 10`
- `nums` 中的所有元素 **互不相同**

```go
func subsets(nums []int) [][]int {
	var res [][]int
	var temp []int
	var dfs func(idx int)
	dfs = func(idx int) {
		t := make([]int, len(temp))
		copy(t, temp)
		res = append(res, t)
		// 路径和当前节点都和i有关，idx只不过是起始位置
		for i := idx; i < len(nums); i++ {
			temp = append(temp, nums[i])
			dfs(i + 1)
			temp = temp[:len(temp) - 1]
		}
	}
	dfs(0)
	return res
}
```



#### [90. 子集 II](https://leetcode-cn.com/problems/subsets-ii/)

难度中等416

给定一个可能包含重复元素的整数数组 ***nums***，返回该数组所有可能的子集（幂集）。

**说明：**解集不能包含重复的子集。

**示例:**

```
输入: [1,2,2]
输出:
[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]
```

```go
// 去重就需要排序+条件判断，这个条件一般都是相邻的两个数相等的话，后面那个数就跳过了
func subsetsWithDup(nums []int) [][]int {
	sort.Ints(nums)
	var res [][]int
	var temp []int
	var dfs func(idx int)
	dfs = func(idx int) {
		t := make([]int, len(temp))
		copy(t, temp)
		res = append(res, t)
		for i := idx; i < len(nums); i++ {
			if i != idx && nums[i] == nums[i - 1] { continue }
			temp = append(temp, nums[i])
			dfs(i + 1)
			temp = temp[:len(temp) - 1]
		}
	}
	dfs(0)
	return res
}
```



#### [491. 递增子序列](https://leetcode-cn.com/problems/increasing-subsequences/)

难度中等261

给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是 2 。

**示例：**

```
输入：[4, 6, 7, 7]
输出：[[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]
```

**提示：**

- 给定数组的长度不会超过15。
- 数组中的整数范围是 [-100,100]。
- 给定数组中可能包含重复数字，相等的数字应该被视为递增的一种情况。

```

```



## 4、排列问题

#### [46. 全排列](https://leetcode-cn.com/problems/permutations/)

难度中等1223

给定一个 **没有重复** 数字的序列，返回其所有可能的全排列。

**示例:**

```
输入: [1,2,3]
输出:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
```

```go
func permute(nums []int) [][]int {
	var res [][]int
	var temp []int
	var dfs func()
	// 用1个数组存一下当前这个位置的数字用没用过，用过就跳过了。
	used := make([]bool, len(nums))
	dfs = func() {
		if len(temp) == len(nums) {
			t := make([]int, len(temp))
			copy(t, temp)
			res = append(res, t)
		}
		for i := 0; i < len(nums); i++ {
			if used[i] { continue }
			used[i] = true
			temp = append(temp, nums[i])
			dfs()
			temp = temp[:len(temp) - 1]
			used[i] = false
		}
	}
	dfs()
	return res
}
```



#### [47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/)

难度中等636

给定一个可包含重复数字的序列 `nums` ，**按任意顺序** 返回所有不重复的全排列。

**示例 1：**

```
输入：nums = [1,1,2]
输出：
[[1,1,2],
 [1,2,1],
 [2,1,1]]
```

**示例 2：**

```
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

**提示：**

- `1 <= nums.length <= 8`
- `-10 <= nums[i] <= 10`

```go
func permuteUnique(nums []int) [][]int {
	sort.Ints(nums)
	var res [][]int
	var temp []int
	var dfs func()
	used := make([]bool, len(nums))
	dfs = func() {
		if len(temp) == len(nums) {
			t := make([]int, len(temp))
			copy(t, temp)
			res = append(res, t)
		}
		for i := 0; i < len(nums); i++ {
			// 去重条件：!used[i - 1]同一层的前一位读过了，所以这次不能读。
			// if i != 0 && nums[i] == nums[i - 1] && used[i - 1] { continue } 也可以
			if i != 0 && nums[i] == nums[i - 1] && !used[i - 1] { continue }
			if used[i] { continue }
			used[i] = true
			temp = append(temp, nums[i])
			dfs()
			temp = temp[:len(temp) - 1]
			used[i] = false
		}
	}
	dfs()
	return res
}
```



## 5、快速幂

#### [50. Pow(x, n)](https://leetcode-cn.com/problems/powx-n/)

难度中等610

实现 [pow(*x*, *n*)](https://www.cplusplus.com/reference/valarray/pow/) ，即计算 x 的 n 次幂函数（即，xn）。

**示例 1：**

```
输入：x = 2.00000, n = 10
输出：1024.00000
```

**示例 2：**

```
输入：x = 2.10000, n = 3
输出：9.26100
```

**示例 3：**

```
输入：x = 2.00000, n = -2
输出：0.25000
解释：2-2 = 1/22 = 1/4 = 0.25
```

**提示：**

- `-100.0 < x < 100.0`
- `-231 <= n <= 231-1`
- `-104 <= xn <= 104`

```go
func myPow(x float64, n int) float64 {
	if n >= 0 {
		return quickMul(x, n)
	}
	return 1.0 / quickMul(x, -n)
}

func quickMul(x float64, n int) float64 {
	res := 1.0
	temp := x
	for n > 0 {
		if n % 2 == 1 {
			res *= temp
		}
		temp *= temp
		n /= 2
	}
	return res
}
```



## 6、棋盘问题

#### [51. N 皇后](https://leetcode-cn.com/problems/n-queens/)

难度困难797

**n 皇后问题** 研究的是如何将 `n` 个皇后放置在 `n×n` 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 `n` ，返回所有不同的 **n 皇后问题** 的解决方案。

每一种解法包含一个不同的 **n 皇后问题** 的棋子放置方案，该方案中 `'Q'` 和 `'.'` 分别代表了皇后和空位。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/13/queens.jpg)

```
输入：n = 4
输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
解释：如上图所示，4 皇后问题存在两个不同的解法。
```

**示例 2：**

```
输入：n = 1
输出：[["Q"]]
```

**提示：**

- `1 <= n <= 9`
- 皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。

```go
func solveNQueens(n int) [][]string {
	bd := make([][]string, n)
	for i := range bd {
		bd[i] = make([]string, n)
		for j := range bd[i] {
			bd[i][j] = "."
		}
	}
	
	// 判断当前位置是否符合要求，
	var isValid func(r, c int, bd [][]string) bool
	isValid = func(r, c int, bd [][]string) bool {
		for i := 0; i < r; i++ {
			for j := 0; j < n; j++ {
				// 列上、两个斜线上是否有Q
				if bd[i][j] == "Q" && (j == c || i+j == r+c || i-j == r-c) {
					return false
				}
			}
		}
		return true
	}
	
	res := [][]string{}
	var helper func(r int, bd [][]string)
	helper = func(r int, bd [][]string) {
		if r == n {
			temp := make([]string, len(bd))
			for i := 0; i < n; i++ {
				temp[i] = strings.Join(bd[i], "")
			}
			res = append(res, temp)
			return
		}
		for c := 0; c < n; c++ {
			// 只有满足要求，才能继续往下走
			if isValid(r, c, bd) {
				bd[r][c] = "Q"
				helper(r+1, bd)
				bd[r][c] = "."
			}
		}
	}

	helper(0, bd)
	return res
}
```



#### [36. 有效的数独](https://leetcode-cn.com/problems/valid-sudoku/)

难度中等484

判断一个 9x9 的数独是否有效。只需要**根据以下规则**，验证已经填入的数字是否有效即可。

1. 数字 `1-9` 在每一行只能出现一次。
2. 数字 `1-9` 在每一列只能出现一次。
3. 数字 `1-9` 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。

![img](https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png)

上图是一个部分填充的有效的数独。

数独部分空格内已填入了数字，空白格用 `'.'` 表示。

**示例 1:**

```
输入:
[
  ["5","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
输出: true
```

**示例 2:**

```
输入:
[
  ["8","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
输出: false
解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。
     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。
```

**说明:**

- 一个有效的数独（部分已被填充）不一定是可解的。
- 只需要根据以上规则，验证已经填入的数字是否有效即可。
- 给定数独序列只包含数字 `1-9` 和字符 `'.'` 。
- 给定数独永远是 `9x9` 形式的。

```go
func isValidSudoku(board [][]byte) bool {
    rowFlag := [9][9]bool{}
    colFlag := [9][9]bool{}
    boxFlag := [9][9]bool{}

    for i := 0; i < 9; i++ {
        for j := 0; j < 9; j++ {
            if board[i][j] != '.' {
                num := int(board[i][j] - '1')
                // 这个是3*3转元素个数为9的数组的过程
                boxIdx := (i / 3) * 3 + j / 3
                if rowFlag[i][num] || colFlag[j][num] || boxFlag[boxIdx][num] {
                    return false
                }
                rowFlag[i][num] = true
                colFlag[j][num] = true
                boxFlag[boxIdx][num] = true
            }
        }
    }
    return true
}
```



#### [37. 解数独](https://leetcode-cn.com/problems/sudoku-solver/)

难度困难791

编写一个程序，通过填充空格来解决数独问题。

一个数独的解法需**遵循如下规则**：

1. 数字 `1-9` 在每一行只能出现一次。
2. 数字 `1-9` 在每一列只能出现一次。
3. 数字 `1-9` 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。

空白格用 `'.'` 表示。

```
Input: board = [
["5","3",".",".","7",".",".",".","."],
["6",".",".","1","9","5",".",".","."],
[".","9","8",".",".",".",".","6","."],
["8",".",".",".","6",".",".",".","3"],
["4",".",".","8",".","3",".",".","1"],
["7",".",".",".","2",".",".",".","6"],
[".","6",".",".",".",".","2","8","."],
[".",".",".","4","1","9",".",".","5"],
[".",".",".",".","8",".",".","7","9"]
]
Output: [
["5","3","4","6","7","8","9","1","2"],
["6","7","2","1","9","5","3","4","8"],
["1","9","8","3","4","2","5","6","7"],
["8","5","9","7","6","1","4","2","3"],
["4","2","6","8","5","3","7","9","1"],
["7","1","3","9","2","4","8","5","6"],
["9","6","1","5","3","7","2","8","4"],
["2","8","7","4","1","9","6","3","5"],
["3","4","5","2","8","6","1","7","9"]
]
```

**提示：**

- 给定的数独序列只包含数字 `1-9` 和字符 `'.'` 。
- 你可以假设给定的数独只有唯一解。
- 给定数独永远是 `9x9` 形式的。

```go
func solveSudoku(board [][]byte)  {
    // 判断是否能把这个数放进数组
    var isValid func(row, col int, val byte) bool
    isValid = func(row, col int, val byte) bool {
        for i := 0; i < 9; i++ {
            if board[row][i] == val { return false }
        }
        for i := 0; i < 9; i++ {
            if board[i][col] == val { return false }
        }

        startRow := (row / 3) * 3;
        startCol := (col / 3) * 3;
        for i := startRow; i < startRow + 3; i++ {
            for j := startCol; j < startCol + 3; j++ {
                if board[i][j] == val { return false }
            }
        }
        return true
    }
	// 这里要有一个返回值，因为if helper() { return true }这里要把k保存在[i][j]位置
    var helper func() bool
    helper = func() bool {
        for i := 0; i < 9; i++ {
            for j := 0; j < 9; j++ {
                if board[i][j] != '.' { continue }
                var k byte
                for k = '1'; k <= '9'; k++ {
                    if isValid(i, j, k) {
                        board[i][j] = k
                        if helper() { return true }// 如果找到合适一组立刻返回
                        board[i][j] = '.'
                    }
                }
                // 没有合适的就返回false
                return false
            }
        }
        return true
    }
    helper()
}
```

