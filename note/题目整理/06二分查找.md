#### [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

难度中等1089

给定一个按照升序排列的整数数组 `nums`，和一个目标值 `target`。找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 `target`，返回 `[-1, -1]`。

**进阶：**

- 你可以设计并实现时间复杂度为 `O(log n)` 的算法解决此问题吗？

**示例 1：**

```
输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]
```

**示例 2：**

```
输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1]
```

**示例 3：**

```
输入：nums = [], target = 0
输出：[-1,-1]
```

**提示：**

- `0 <= nums.length <= 105`
- `-109 <= nums[i] <= 109`
- `nums` 是一个非递减数组
- `-109 <= target <= 109`

```
func searchRange(nums []int, target int) []int {
    ans := []int{-1, -1}
    if len(nums) == 0 { return ans }
    l, r := 0, len(nums)
    for l < r {
        m := l + (r - l) / 2
        if target == nums[m] {
            r = m
        } else if target > nums[m] {
            l = m + 1
        } else if target < nums[m] {
            r = m
        }
    }
    // r或者l是target的第一个位置，所以如果nums的最大值<target，r=len(nums)
    if r >= len(nums) || nums[r] != target {
        return ans
    }
    ans[0] = l
    l, r = 0, len(nums)
    for l < r {
        m := l + (r - l) / 2
        if target == nums[m] {
            l = m + 1
        } else if target > nums[m] {
            l = m + 1
        } else if target < nums[m] {
            r = m
        }
    }
    ans[1] = l - 1
    return ans
}
```



#### [74. 搜索二维矩阵](https://leetcode-cn.com/problems/search-a-2d-matrix/)

难度中等451

编写一个高效的算法来判断 `m x n` 矩阵中，是否存在一个目标值。该矩阵具有如下特性：

- 每行中的整数从左到右按升序排列。
- 每行的第一个整数大于前一行的最后一个整数。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/05/mat.jpg)

```
输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
输出：true
```

**示例 2：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/mat2.jpg)

```
输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13
输出：false
```

**提示：**

- `m == matrix.length`
- `n == matrix[i].length`
- `1 <= m, n <= 100`
- `-104 <= matrix[i][j], target <= 104`

```
func searchMatrix(matrix [][]int, target int) bool {
    first, last := 0, len(matrix[0]) - 1
    l, r := 0, len(matrix) - 1
    for l <= r {
        m := (l + r) / 2
        if target < matrix[m][first] {
            r = m - 1
        } else if target > matrix[m][last] {
            l = m + 1
        } else {
            return search(matrix[m], target)
        }
    }
    return false
}

func search(nums []int, target int) bool {
    l, r := 0, len(nums) - 1
    for  l <= r {
        m := (l + r) / 2
        if target == nums[m] {
            return true
        }
        if target < nums[m] {
            r = m - 1
        } else {
            l = m + 1
        }
    }
    return false
}
```



#### [33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

难度中等1428

整数数组 `nums` 按升序排列，数组中的值 **互不相同** 。

在传递给函数之前，`nums` 在预先未知的某个下标 `k`（`0 <= k < nums.length`）上进行了 **旋转**，使数组变为 `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`（下标 **从 0 开始** 计数）。例如， `[0,1,2,4,5,6,7]` 在下标 `3` 处经旋转后可能变为 `[4,5,6,7,0,1,2]` 。

给你 **旋转后** 的数组 `nums` 和一个整数 `target` ，如果 `nums` 中存在这个目标值 `target` ，则返回它的下标，否则返回 `-1` 。

**示例 1：**

```
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
```

**示例 2：**

```
输入：nums = [4,5,6,7,0,1,2], target = 3
输出：-1
```

**示例 3：**

```
输入：nums = [1], target = 0
输出：-1
```

**提示：**

- `1 <= nums.length <= 5000`
- `-10^4 <= nums[i] <= 10^4`
- `nums` 中的每个值都 **独一无二**
- 题目数据保证 `nums` 在预先未知的某个下标上进行了旋转
- `-10^4 <= target <= 10^4`

```
func search(nums []int, target int) int {
    l, r := 0, len(nums) - 1
    for l <= r {
        m := l + (r - l) / 2
        if target == nums[m] { return m }
        // 先判断哪边是有序的，再更新l,r
        if nums[l] < nums[m] {
            if target < nums[m] && target >= nums[l] {
                r = m - 1
            } else {
                l = m + 1
            }
        } else {
            if target > nums[m] && target <= nums[r] {
                l = m + 1
            } else {
                r = m - 1
            }
        }
    }
    return -1
}
```



#### [69. x 的平方根](https://leetcode-cn.com/problems/sqrtx/)

难度简单707

实现 `int sqrt(int x)` 函数。

计算并返回 *x* 的平方根，其中 *x* 是非负整数。

由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。

**示例 1:**

```
输入: 4
输出: 2
```

**示例 2:**

```
输入: 8
输出: 2
说明: 8 的平方根是 2.82842..., 
     由于返回类型是整数，小数部分将被舍去。
```

```
func mySqrt(x int) int {
    l, r := 0, x
    ans := 0
    for l <= r {
        m := l + (r - l) / 2
        if m * m <= x {
            ans = m
            l = m + 1
        } else {
            r = m - 1
        }
    }
    return ans
}
```



#### [367. 有效的完全平方数](https://leetcode-cn.com/problems/valid-perfect-square/)

难度简单229

给定一个 **正整数** `num` ，编写一个函数，如果 `num` 是一个完全平方数，则返回 `true` ，否则返回 `false` 。

**进阶：不要** 使用任何内置的库函数，如 `sqrt` 。

**示例 1：**

```
输入：num = 16
输出：true
```

**示例 2：**

```
输入：num = 14
输出：false
```

**提示：**

- `1 <= num <= 2^31 - 1`

```
func isPerfectSquare(num int) bool {
    l, r := 0, num
    for l <= r {
        m := l + (r - l) / 2
        if m * m == num { return true }
        if m * m < num {
            l = m + 1
        } else {
            r = m - 1
        }
    }
    return false
}
```



#### [153. 寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)

难度中等510

已知一个长度为 `n` 的数组，预先按照升序排列，经由 `1` 到 `n` 次 **旋转** 后，得到输入数组。例如，原数组 `nums = [0,1,2,4,5,6,7]` 在变化后可能得到：

- 若旋转 `4` 次，则可以得到 `[4,5,6,7,0,1,2]`
- 若旋转 `7` 次，则可以得到 `[0,1,2,4,5,6,7]`

注意，数组 `[a[0], a[1], a[2], ..., a[n-1]]` **旋转一次** 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]` 。

给你一个元素值 **互不相同** 的数组 `nums` ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 **最小元素** 。

**示例 1：**

```
输入：nums = [3,4,5,1,2]
输出：1
解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。
```

**示例 2：**

```
输入：nums = [4,5,6,7,0,1,2]
输出：0
解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。
```

**示例 3：**

```
输入：nums = [11,13,15,17]
输出：11
解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。
```

**提示：**

- `n == nums.length`
- `1 <= n <= 5000`
- `-5000 <= nums[i] <= 5000`
- `nums` 中的所有整数 **互不相同**
- `nums` 原来是一个升序排序的数组，并进行了 `1` 至 `n` 次旋转

```
func findMin(nums []int) int {
    l, r := 0, len(nums) - 1
    ans := math.MaxInt32
    for l <= r {
        m := l + (r - l) / 2
        if nums[m] < ans {
            ans = nums[m]
        }
        if nums[m] < nums[r] {
        	// 右边有序，最小值在左边
            r = m - 1
        } else {
            l = m + 1
        }
    }
    return ans
}
```



#### [162. 寻找峰值](https://leetcode-cn.com/problems/find-peak-element/)

难度中等452

峰值元素是指其值大于左右相邻值的元素。

给你一个输入数组 `nums`，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 **任何一个峰值** 所在位置即可。

你可以假设 `nums[-1] = nums[n] = -∞` 。

**示例 1：**

```
输入：nums = [1,2,3,1]
输出：2
解释：3 是峰值元素，你的函数应该返回其索引 2。
```

**示例 2：**

```
输入：nums = [1,2,1,3,5,6,4]
输出：1 或 5 
解释：你的函数可以返回索引 1，其峰值元素为 2；
     或者返回索引 5， 其峰值元素为 6。
```

**提示：**

- `1 <= nums.length <= 1000`
- `-231 <= nums[i] <= 231 - 1`
- 对于所有有效的 `i` 都有 `nums[i] != nums[i + 1]`

```
func findPeakElement(nums []int) int {
    l, r := 0, len(nums) - 1
    for l < r {
        m := l + (r - l) / 2
        if nums[m] > nums[m + 1] {
            // 峰值在左边
            r = m
        } else {
            l = m + 1
        }
    }
    return l
}
```

