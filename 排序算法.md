# 一、如何分析排序算法

## 1、时间复杂度

#### 1.1最好情况、最坏情况、平均情况

有的排序算法这几种情况区别比较大；

数据有序度不同，对排序时间有影响，数据有序度对不同排序算法的影响程度也不同。

#### 1.2时间复杂度的系数、常数、低阶

小规模数据的排序需要考虑这些。

#### 1.3比较和交换次数

基于比较的排序算法的执行过程，会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。

## 2、空间复杂度

原地排序（Sorted in place）：指空间复杂度是 O(1) 的排序算法。

## 3、稳定性

稳定性：如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。

稳定的排序算法：相等的值在排序前后相对顺序没改变。

不稳定的排序算法：相等的值在排序前后相对顺序发生改变。

# 二、冒泡排序

## 1、原理与代码

冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。如果是从小到大的排序，每次冒泡都会把最大的数放在最后。

```
func BubbleSort(a []int, n int) {
    if n <= 1 {
		return
	}
	for i := 0; i < n; i++ {
		for j := 0; j < n-i-1; j++ {
			if a[j] > a[j+1] {
				a[j], a[j+1] = a[j+1], a[j]
			}
		}
	}
}
```

#### 1.1一个简单的优化

使用一个标志位，当一次没有元素交换的时候，说明数组已经有序了，这时就可以直接返回了。

```
func BubbleSort(a []int, n int) {
	if n <= 1 {
		return
	}
	for i := 0; i < n; i++ {
		// 提前退出标志
		flag := false
		for j := 0; j < n-i-1; j++ {
			if a[j] > a[j+1] {
				a[j], a[j+1] = a[j+1], a[j]
				//此次冒泡有数据交换
				flag = true
			}
		}
		// 如果没有交换数据，提前退出
		if !flag {
			break
		}
	}
}
```

## 2、分析

是原地排序算法：只涉及相邻元素交换，不需要额外的空间。

是稳定的排序算法：当两个元素相等的时候，不交换就稳定了。

时间复杂度：最好O(n)；最坏O(n^2)；平均O(n^2)。

# 三、插入排序

## 1、原理与代码

#### 1.1算法过程：

1. 将数组中的数据分为两个区间，已排序区间和未排序区间。初始已排序区间只有数组的第一个元素。
2. 取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。
3. 重复第二步，直到未排序区间为空。

#### 1.2第二步的实现：

当将一个数据 a 插入到已排序区间时，需要拿 a 与已排序区间的元素依次比较大小，找到合适的插入位置。找到插入点之后，还需要将插入点之后的元素顺序往后移动一位，这样才能腾出位置给元素 a 插入。

#### 1.3代码：

```
func InsertionSort(a []int, n int) {
	if n <= 1 {
		return
	}
	for i := 1; i < n; i++ {
		value := a[i]
		//查找要插入的位置并移动数据
		for j := i - 1; j >= 0; j-- {
			if a[j] > value {
				a[j+1] = a[j]
			} else {
				break
			}
		}
		a[j+1] = value
	}
}
```

## 2、分析

是原地排序算法：只涉及相邻元素交换，不需要额外的空间。

是稳定的排序算法：当两个元素相等的时候，将后面出现的元素，插入到前面出现元素的后面。

时间复杂度：最好O(n)；最坏O(n^2)；平均O(n^2)。

# 四、选择排序

## 1、原理与代码

将数组分为已排序区间和未排序区间。选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。

```
func SelectionSort(a []int, n int) {
	if n <= 1 {
		return
	}
	for i := 0; i < n; i++ {
		// 查找最小值
		minIndex := i
		for j := i + 1; j < n; j++ {
			if a[j] < a[minIndex] {
				minIndex = j
			}
		}
		// 交换
		a[i], a[minIndex] = a[minIndex], a[i]
	}
}
```

## 2、分析

是原地排序算法：只涉及相邻元素交换，不需要额外的空间。

是不稳定的排序算法：每次找到未排序区间的最小值，与前面的元素交换位置，破坏了稳定性。

时间复杂度：最好O(n)；最坏O(n^2)；平均O(n^2)。

# 五、归并算法

## 1、归并算法思想

归并算法是典型的分治思想，将一个大问题分解成小的子问题来解决。放在排序中就是，先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。

## 2、代码

#### 2.1递归以代码一般模板

```c
void recursion(int level, int param) { 
	// 递归终止条件
	if (level > MAX_LEVEL) { 
		// 处理结果
    	return ; 
	}

	// 处理当前逻辑
	process(level, param);

	// 下探到下一层
	recursion(level + 1, param);

	// 恢复当前level状态，一般回溯算法需要添加逻辑
}
```

#### 2.2衍生到分治代码模板

```c
int divide_conquer(Problem *problem, int params) {
	// 递归终止条件
	if (problem == nullptr) {
    	// 处理结果
    	return result;
	} 

	// 处理当前层（计算子问题）
	subproblems = split_problem(problem, data)
	
	// 下探到下一层，下探到子问题
	subresult1 = divide_conquer(subproblem[0], p1)
	subresult2 = divide_conquer(subproblem[1], p1)
	subresult3 = divide_conquer(subproblem[2], p1)

	// 合并结果
	result = process_result(subresult1, subresult2, subresult3)
	
	// 恢复当前level状态，一般回溯算法需要添加逻辑
}
```

#### 2.3排序算法的实现：

```go
func MergeSort(arr []int) {
	arrLen := len(arr)
	if arrLen <= 1 {
		return
	}

	mergeSort(arr, 0, arrLen-1)
}

func mergeSort(arr []int, start, end int) {
    // 递归终止条件
	if start >= end {
		return
	}
	
    // 处理当前层，当前层只需要计算mid。
	mid := (start + end) / 2
	// 下探到下一层，下一层就是数组的左一半和右一半
    mergeSort(arr, start, mid)
	mergeSort(arr, mid+1, end)
    // 合并当前层，合并就是排序的过程。
	merge(arr, start, mid, end)
}

func merge(arr []int, start, mid, end int) {
	tmpArr := make([]int, end-start+1)

	i := start
	j := mid + 1
	k := 0
	for ; i <= mid && j <= end; k++ {
		if arr[i] <= arr[j] {
			tmpArr[k] = arr[i]
			i++
		} else {
			tmpArr[k] = arr[j]
			j++
		}
	}

	for ; i <= mid; i++ {
		tmpArr[k] = arr[i]
		k++
	}
	for ; j <= end; j++ {
		tmpArr[k] = arr[j]
		k++
	}
	copy(arr[start:end+1], tmpArr)
}
```

## 3、性能分析

不是原地排序算法：合并函数无法在原地执行。临时内存空间最大也不会超过 n 个数据的大小，所以空间复杂度是 O(n)。

是稳定的排序算法：放入tmp数组的时候，保证相同元素前后顺序不变，保证了稳定。

时间复杂度：最好、最坏、平均都是O(nlogn)。

# 六、快速排序

## 1、快排思想

1. 如果要排序数组中下标从 p 到 r 之间的一组数据，选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。
2. 遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。
3. 经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的。
4. 根据分治、递归的处理思想，我们可以用递归排序下标从 p 到 q-1 之间的数据和下标从 q+1 到 r 之间的数据，直到区间缩小为 1

## 2、代码

由于快排也是分支的思想，所以也可以用递归模板来写

```go
func QuickSort(arr []int) {
	separateSort(arr, 0, len(arr)-1)
}

func separateSort(arr []int, start, end int) {
    // 递归终止条件
	if start >= end {
		return
	}
    // 处理当前层，完成当前层的分区
	i := partition(arr, start, end)
    
    // 下探到左子问题
	separateSort(arr, start, i-1)
    
    // 下探到右子问题
	separateSort(arr, i+1, end)
}

func partition(arr []int, start, end int) int {
	// 选取最后一位当对比数字
	pivot := arr[end]

	var i = start
	for j := start; j < end; j++ {
		if arr[j] < pivot {
			if !(i == j) {
				// 保证<pivot的数在前面，>pivot的数在后面
				arr[i], arr[j] = arr[j], arr[i]
			}
			i++
		}
	}

	arr[i], arr[end] = arr[end], arr[i]

	return i
}
```

- 归并排序的处理过程是由下到上的，先处理子问题，然后再合并；
- 快排正好相反，它的处理过程是由上到下的，先分区，然后再处理子问题。

## 3、快排分析

原地排序算法：使用原地分区的函数，就可以实现原地排序。空间复杂度就是O(1)

不稳定的排序算法：分区过程会打乱相同元素的相对顺序

时间复杂度：

- 当分区用的元素比较合理，能比较平均的进行分区，时间复杂度O(nlogn)
- 当每次选的元素都不合理，分区都极其不均衡，最坏时间复杂度为O(n^2)
- 但是大多数都是O(nlogn)，所以平均时间复杂度就是O(nlogn)





