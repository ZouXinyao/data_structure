## 题目汇总：

### 打家劫舍：

#### 198、213、337

### 类暴力法+双指针：

#### 139、713

### 前缀和：

#### 303、304、525、560、363

### 前缀积：

#### 238、713

### 子数组问题：

#### 525、560、53、32、801

### 子序列问题：

#### 673、300、1143、115、873、1027、413、583、

### 股票问题：

#### 121、122、309、714、123、188

### 子集问题(可以排序)：

#### 368

### 不同元素导致条件不同的dp问题：

#### 91(根据元素的值)、338(根据奇偶)、871(根据距离)、343(根据除后余数)

### 路径问题(输入就是二维数组)：

#### 120、64、221、62、63、

### 回文串：

#### 132、5、647、516

### 背包问题：

#### 1049、322、518、474、416、377、494

### 二叉搜索树相关：

#### 96、95

### 其他(难题)

#### 887、312、546

## 具体题解：

#### [746. 使用最小花费爬楼梯](https://leetcode-cn.com/problems/min-cost-climbing-stairs/)

数组的每个下标作为一个阶梯，第 `i` 个阶梯对应着一个非负数的体力花费值 `cost[i]`（下标从 `0` 开始）。

每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。

请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。

**示例 1：**

```
输入：cost = [10, 15, 20]
输出：15
解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。
```

 **示例 2：**

```
输入：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]
输出：6
解释：最低花费方式是从 cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，一共花费 6 。
```

**提示：**

- `cost` 的长度范围是 `[2, 1000]`。
- `cost[i]` 将会是一个整型数据，范围为 `[0, 999]` 。

```go
func minCostClimbingStairs(cost []int) int {
    dp := make([]int, len(cost))
    dp[0] = cost[0]
    dp[1] = cost[1]
    for i := 2; i < len(cost); i++ {
        dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i]
    }
    return min(dp[len(cost) - 1], dp[len(cost) - 2])

}

func min(a, b int) int {
	if a < b { return a }
	return b
}
```

#### [198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。

**示例 1：**

```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

**示例 2：**

```
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

**提示：**

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 400`

```go
func rob(nums []int) int {
    dp := make([]int, len(nums) + 1)
    dp[0] = 0
    dp[1] = nums[0]
    for i := 2; i < len(nums) + 1; i++ {
        dp[i] = max(nums[i - 1] + dp[i - 2], dp[i - 1])
    }
    return dp[len(nums)]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### [213. 打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 **围成一圈** ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警** 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **在不触动警报装置的情况下** ，今晚能够偷窃到的最高金额。

**示例 1：**

```
输入：nums = [2,3,2]
输出：3
解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
```

**示例 2：**

```
输入：nums = [1,2,3,1]
输出：4
解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

**示例 3：**

```
输入：nums = [0]
输出：0
```

**提示：**

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 1000`

```go
func rob(nums []int) int {
    n := len(nums)
    if n == 1 {return nums[0]}
    dp0 := make([]int, n)
    dp1 := make([]int, n)
    // dp0，最后一家不偷，第一家偷；dp1，偷最后一家，不偷第一家。
    dp0[0] = nums[0]
    dp0[1] = nums[0]
    dp1[1] = nums[1]
    for i := 2; i < len(nums); i++ {
        dp0[i] = max(dp0[i - 1], dp0[i - 2] + nums[i])
        dp1[i] = max(dp1[i - 1], dp1[i - 2] + nums[i])
    }
    return max(dp0[n - 2], dp1[n - 1])

}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### [337. 打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)

在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。

计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。

**示例 1:**

```
输入: [3,2,3,null,3,null,1]

     3
    / \
   2   3
    \   \ 
     3   1

输出: 7 
解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.
```

**示例 2:**

```
输入: [3,4,5,1,3,null,1]

     3
    / \
   4   5
  / \   \ 
 1   3   1

输出: 9
解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.
```

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func rob(root *TreeNode) int {
    var dfs func(node *TreeNode) (s, ns int)
    dfs = func(node *TreeNode) (s, ns int) {
        if node == nil {
            return 0, 0
        }
        ls, lns := dfs(node.Left)
        rs, rns := dfs(node.Right)

        s = node.Val + lns + rns
        ns = max(ls, lns) + max(rs, rns)
        return 
    }
    s, ns := dfs(root)
    return max(s, ns)
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```

#### [139. 单词拆分](https://leetcode-cn.com/problems/word-break/)

给定一个**非空**字符串 *s* 和一个包含**非空**单词的列表 *wordDict*，判定 *s* 是否可以被空格拆分为一个或多个在字典中出现的单词。

**说明：**

- 拆分时可以重复使用字典中的单词。
- 你可以假设字典中没有重复的单词。

**示例 1：**

```
输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。
```

**示例 2：**

```
输入: s = "applepenapple", wordDict = ["apple", "pen"]
输出: true
解释: 返回 true 因为 "applepenapple" 可以被拆分成 "apple pen apple"。
     注意你可以重复使用字典中的单词。
```

**示例 3：**

```
输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
输出: false
```

```go
func wordBreak(s string, wordDict []string) bool {
    dp := make([]bool, len(s) + 1)
    visited := map[string]bool{}
    for _, word := range wordDict{
        visited[word] = true
    }
    dp[0] = true
    for i := 1; i < len(s) + 1; i++ {
        for j := 0; j < i; j++ {
            str := s[j: i]
            if dp[j] == true && visited[str] == true {
                dp[i] = true
            }
        }
    }
    return dp[len(s)]
}
```

#### [303. 区域和检索 - 数组不可变](https://leetcode-cn.com/problems/range-sum-query-immutable/)

给定一个整数数组  `nums`，求出数组从索引 `i` 到 `j`（`i ≤ j`）范围内元素的总和，包含 `i`、`j `两点。

实现 `NumArray` 类：

- `NumArray(int[] nums)` 使用数组 `nums` 初始化对象
- `int sumRange(int i, int j)` 返回数组 `nums` 从索引 `i` 到 `j`*（*`i ≤ j`）范围内元素的总和，包含 `i`、`j `两点（也就是 `sum(nums[i], nums[i + 1], ... , nums[j])`）

**示例：**

```
输入：
["NumArray", "sumRange", "sumRange", "sumRange"]
[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]
输出：
[null, 1, -1, -3]

解释：
NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);
numArray.sumRange(0, 2); // return 1 ((-2) + 0 + 3)
numArray.sumRange(2, 5); // return -1 (3 + (-5) + 2 + (-1)) 
numArray.sumRange(0, 5); // return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1))
```

**提示：**

- `0 <= nums.length <= 104`
- `-105 <= nums[i] <= 105`
- `0 <= i <= j < nums.length`
- 最多调用 `104` 次 `sumRange` 方法

```go
type NumArray struct {
    sumArr []int
}


func Constructor(nums []int) NumArray {
    dp := make([]int, len(nums) + 1)
    dp[0] = 0
    for i := 1; i < len(nums) + 1; i++ {
        dp[i] = dp[i - 1] + nums[i - 1]
    }
    return NumArray{
        sumArr: dp,
    }
    
}


func (this *NumArray) SumRange(left int, right int) int {
    return this.sumArr[right + 1] - this.sumArr[left]
}


/**
 * Your NumArray object will be instantiated and called as such:
 * obj := Constructor(nums);
 * param_1 := obj.SumRange(left,right);
 */
```

#### [304. 二维区域和检索 - 矩阵不可变](https://leetcode-cn.com/problems/range-sum-query-2d-immutable/)

给定一个二维矩阵，计算其子矩形范围内元素的总和，该子矩阵的左上角为 `(row1, col1)` ，右下角为 `(row2, col2)` 。

![Range Sum Query 2D](https://assets.leetcode-cn.com/aliyun-lc-upload/images/304.png)
上图子矩阵左上角 (row1, col1) = **(2, 1)** ，右下角(row2, col2) = **(4, 3)，**该子矩形内元素的总和为 8。

**示例：**

```
给定 matrix = [
  [3, 0, 1, 4, 2],
  [5, 6, 3, 2, 1],
  [1, 2, 0, 1, 5],
  [4, 1, 0, 1, 7],
  [1, 0, 3, 0, 5]
]

sumRegion(2, 1, 4, 3) -> 8
sumRegion(1, 1, 2, 2) -> 11
sumRegion(1, 2, 2, 4) -> 12
```

**提示：**

- 你可以假设矩阵不可变。
- 会多次调用 `sumRegion` 方法*。*
- 你可以假设 `row1 ≤ row2` 且 `col1 ≤ col2` 。

```go
type NumMatrix struct {
	sums [][]int
}


func Constructor(matrix [][]int) NumMatrix {
	dp := make([][]int, len(matrix) + 1)
	for i := 0; i < len(matrix) + 1; i++ {
		dp[i] = make([]int, len(matrix[0]) + 1)
	}

	for i := 1; i < len(matrix) + 1; i++ {
		for j := 1; j < len(matrix[0]) + 1; j++ {
			dp[i][j] = matrix[i - 1][j - 1] + dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1]
		}
	}

	return NumMatrix{
		sums: dp,
	}
}


func (this *NumMatrix) SumRegion(row1 int, col1 int, row2 int, col2 int) int {
	row1++
	row2++
	col1++
	col2++
	return this.sums[row2][col2] + this.sums[row1 - 1][col1 - 1] - this.sums[row1 - 1][col2] - this.sums[row2][col1 - 1]
}


/**
 * Your NumMatrix object will be instantiated and called as such:
 * obj := Constructor(matrix);
 * param_1 := obj.SumRegion(row1,col1,row2,col2);
 */

```

#### [525. 连续数组](https://leetcode-cn.com/problems/contiguous-array/)

给定一个二进制数组 `nums` , 找到含有相同数量的 `0` 和 `1` 的最长连续子数组，并返回该子数组的长度。

**示例 1:**

```
输入: nums = [0,1]
输出: 2
说明: [0, 1] 是具有相同数量 0 和 1 的最长连续子数组。
```

**示例 2:**

```
输入: nums = [0,1,0]
输出: 2
说明: [0, 1] (或 [1, 0]) 是具有相同数量0和1的最长连续子数组。
```

**提示：**

- `1 <= nums.length <= 105`
- `nums[i]` 不是 `0` 就是 `1`

```go
func findMaxLength(nums []int) int {
    ans := 0
    sum := 0
    sumMap := map[int]int{}
    sumMap[0] = -1
    for i := 0; i < len(nums); i++ {
        if nums[i] == 0 {
            sum -= 1
        } else {
            sum += 1
        }
        if v, ok := sumMap[sum]; ok {
            ans = max(i - v, ans)
        } else {
            sumMap[sum] = i
        }
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### [53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**示例 1：**

```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```

**示例 2：**

```
输入：nums = [1]
输出：1
```

**示例 3：**

```
输入：nums = [0]
输出：0
```

**示例 4：**

```
输入：nums = [-1]
输出：-1
```

**示例 5：**

```
输入：nums = [-100000]
输出：-100000
```

**提示：**

- `1 <= nums.length <= 3 * 104`
- `-105 <= nums[i] <= 105`

```go
func maxSubArray(nums []int) int {
    dp := make([]int, len(nums))
    dp[0] = nums[0]
    res := nums[0]
    for i := 1; i < len(dp); i++ {
        dp[i] = max(dp[i - 1] + nums[i], nums[i])
        res = max(dp[i], res)
    }
    return res
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### [560. 和为K的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/)

给定一个整数数组和一个整数 **k，**你需要找到该数组中和为 **k** 的连续的子数组的个数。

**示例 1 :**

```
输入:nums = [1,1,1], k = 2
输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。
```

**说明 :**

1. 数组的长度为 [1, 20,000]。
2. 数组中元素的范围是 [-1000, 1000] ，且整数 **k** 的范围是 [-1e7, 1e7]。

```go
func subarraySum(nums []int, k int) int {
    m := map[int]int{}
    m[0] = 1
    sum := 0
    ans := 0
    for _, num := range nums {
        sum += num
        if v, ok := m[sum - k]; ok {
            ans += v
        }
        m[sum]++
    }
    return ans
}
```

#### [152. 乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray/)

给你一个整数数组 `nums` ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

**示例 1:**

```
输入: [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
```

**示例 2:**

```
输入: [-2,0,-1]
输出: 0
解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。
```

```go
func maxProduct(nums []int) int {
    ans := math.MinInt32
    maxNum, minNum := 1, 1
    for _, num := range nums {
        maxN := max(max(minNum * num, num), maxNum * num)
        minN := min(min(minNum * num, num), maxNum * num)
        ans = max(ans, maxN)
        maxNum, minNum = maxN, minN
    }
    return ans
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### [238. 除自身以外数组的乘积](https://leetcode-cn.com/problems/product-of-array-except-self/)

给你一个长度为 *n* 的整数数组 `nums`，其中 *n* > 1，返回输出数组 `output` ，其中 `output[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积。

**示例:**

```
输入: [1,2,3,4]
输出: [24,12,8,6]
```

**提示：**题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。

**说明:** 请**不要使用除法，**且在 O(*n*) 时间复杂度内完成此题。

**进阶：**
你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组**不被视为**额外空间。）

```go
func productExceptSelf(nums []int) []int {
    l := len(nums)
    dp0 := make([]int, l)
    dp1 := make([]int, l)
    for i := 0; i < l; i++ {
        dp0[i] = 1
        dp1[i] = 1
    }
    for i := 1; i < l; i++ {
        dp0[i] = dp0[i - 1] * nums[i - 1]
    }
    for i := l - 2; i >= 0; i-- {
        dp1[i] = dp1[i + 1] * nums[i + 1]
    }
    for i := 0; i < l; i++ {
        dp0[i] *= dp1[i]
    }
    return dp0
}
```

#### [724. 寻找数组的中心下标](https://leetcode-cn.com/problems/find-pivot-index/)

给你一个整数数组 `nums` ，请计算数组的 **中心下标** 。

数组 **中心下标** 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。

如果中心下标位于数组最左端，那么左侧数之和视为 `0` ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。

如果数组有多个中心下标，应该返回 **最靠近左边** 的那一个。如果数组不存在中心下标，返回 `-1` 。

**示例 1：**

```
输入：nums = [1, 7, 3, 6, 5, 6]
输出：3
解释：
中心下标是 3 。
左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 ，
右侧数之和 sum = nums[4] + nums[5] = 5 + 6 = 11 ，二者相等。
```

**示例 2：**

```
输入：nums = [1, 2, 3]
输出：-1
解释：
数组中不存在满足此条件的中心下标。
```

**示例 3：**

```
输入：nums = [2, 1, -1]
输出：0
解释：
中心下标是 0 。
左侧数之和 sum = 0 ，（下标 0 左侧不存在元素），
右侧数之和 sum = nums[1] + nums[2] = 1 + -1 = 0 。
```

**提示：**

- `1 <= nums.length <= 104`
- `-1000 <= nums[i] <= 1000`

```go
func pivotIndex(nums []int) int {
    var sum1 int
    for _, num := range nums {
        sum1 += num
    }
    var sum2 int
    for i, num := range nums {
        sum2 += num
        if sum1 == sum2 {
            return i
        }
        sum1 -= num
    }
    return -1
}
```

#### [713. 乘积小于K的子数组](https://leetcode-cn.com/problems/subarray-product-less-than-k/)

给定一个正整数数组 `nums`。

找出该数组内乘积小于 `k` 的连续的子数组的个数。

**示例 1:**

```
输入: nums = [10,5,2,6], k = 100
输出: 8
解释: 8个乘积小于100的子数组分别为: [10], [5], [2], [6], [10,5], [5,2], [2,6], [5,2,6]。
需要注意的是 [10,5,2] 并不是乘积小于100的子数组。
```

**说明:**

- `0 < nums.length <= 50000`
- `0 < nums[i] < 1000`
- `0 <= k < 10^6`

```go
func numSubarrayProductLessThanK(nums []int, k int) int {
    if k <= 1 { return 0 }
    l, r := 0, 0
    mul, ans := 1, 0
    for ;r < len(nums); r++ {
        mul *= nums[r]
        for mul >= k {
            mul /= nums[l]
            l++
        }
        ans += (r - l + 1)
    }
    return ans
}
```

#### [801. 使序列递增的最小交换次数](https://leetcode-cn.com/problems/minimum-swaps-to-make-sequences-increasing/)

我们有两个长度相等且不为空的整型数组 `A` 和 `B` 。

我们可以交换 `A[i]` 和 `B[i]` 的元素。注意这两个元素在各自的序列中应该处于相同的位置。

在交换过一些元素之后，数组 `A` 和 `B` 都应该是严格递增的（数组严格递增的条件仅为`A[0] < A[1] < A[2] < ... < A[A.length - 1]`）。

给定数组 `A` 和 `B` ，请返回使得两个数组均保持严格递增状态的最小交换次数。假设给定的输入总是有效的。

```
示例:
输入: A = [1,3,5,4], B = [1,2,3,7]
输出: 1
解释: 
交换 A[3] 和 B[3] 后，两个数组如下:
A = [1, 3, 5, 7] ， B = [1, 2, 3, 4]
两个数组均为严格递增的。
```

**注意:**

- `A, B` 两个数组的长度总是相等的，且长度的范围为 `[1, 1000]`。
- `A[i], B[i]` 均为 `[0, 2000]`区间内的整数。

```go
func minSwap(nums1 []int, nums2 []int) int {
    n := len(nums1)
    dp0 := make([]int, n)
    dp1 := make([]int, n)
    dp1[0] = 1
    for i := 1; i < n; i++ {
        if nums1[i] > nums1[i - 1] && nums2[i] > nums2[i - 1] {
            if nums1[i] > nums2[i - 1] && nums2[i] > nums1[i - 1] {
                dp0[i] = min(dp0[i - 1], dp1[i - 1])
                dp1[i] = min(dp0[i - 1], dp1[i - 1]) + 1
            } else {
                dp0[i] = dp0[i - 1]
                dp1[i] = dp1[i - 1] + 1
            }
        } else {
            dp0[i] = dp1[i - 1]
            dp1[i] = dp0[i - 1] + 1
        }
    }
    return min(dp0[n - 1], dp1[n - 1])
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}

```

#### [673. 最长递增子序列的个数](https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/)

给定一个未排序的整数数组，找到最长递增子序列的个数。

**示例 1:**

```
输入: [1,3,5,4,7]
输出: 2
解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。
```

**示例 2:**

```
输入: [2,2,2,2,2]
输出: 5
解释: 最长递增子序列的长度是1，并且存在5个子序列的长度为1，因此输出5。
```

**注意:** 给定的数组长度不超过 2000 并且结果一定是32位有符号整数。

```go
func findNumberOfLIS(nums []int) int {
    l := len(nums)
    dp := make([]int, l)
    cnt := make([]int, l)
    for i := 0; i < l; i++ {
        dp[i] = 1
        cnt[i] = 1
    }
    var maxCnt int
    maxCnt = cnt[0]
    for i := 1; i < l; i++ {
        for j := 0; j < i; j++ {
            if nums[j] < nums[i] {
                if dp[i] == dp[j] + 1 {
                    cnt[i] += cnt[j]
                } else if dp[i] < dp[j] + 1 {
                    cnt[i] = cnt[j]
                }
                dp[i] = max(dp[i], dp[j] + 1)
            }
        }
        maxCnt = max(maxCnt, dp[i])
    }
    var ans int
    for i := 0; i < l; i++ {
        if maxCnt == dp[i] {
            ans += cnt[i]
        }
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### [300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。

**示例 1：**

```
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```

**示例 2：**

```
输入：nums = [0,1,0,3,2,3]
输出：4
```

**示例 3：**

```
输入：nums = [7,7,7,7,7,7,7]
输出：1
```

**提示：**

- `1 <= nums.length <= 2500`
- `-104 <= nums[i] <= 104`

**进阶：**

- 你可以设计时间复杂度为 `O(n2)` 的解决方案吗？
- 你能将算法的时间复杂度降低到 `O(n log(n))` 吗?

```go
func lengthOfLIS(nums []int) int {
    l := len(nums)
    dp := make([]int, l)
    for i := 0; i < l; i++ {
        dp[i] = 1
    }
    maxLen := dp[0]
    for i := 1; i < l; i++ {
        for j := 0; j < i; j++ {
            if nums[j] < nums[i] {
                dp[i] = max(dp[i], dp[j] + 1)
            }
        }
        maxLen = max(maxLen, dp[i])
    }
    
    return maxLen
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### [1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 **公共子序列** ，返回 `0` 。

一个字符串的 **子序列** 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

- 例如，`"ace"` 是 `"abcde"` 的子序列，但 `"aec"` 不是 `"abcde"` 的子序列。

两个字符串的 **公共子序列** 是这两个字符串所共同拥有的子序列。

**示例 1：**

```
输入：text1 = "abcde", text2 = "ace" 
输出：3  
解释：最长公共子序列是 "ace" ，它的长度为 3 。
```

**示例 2：**

```
输入：text1 = "abc", text2 = "abc"
输出：3
解释：最长公共子序列是 "abc" ，它的长度为 3 。
```

**示例 3：**

```
输入：text1 = "abc", text2 = "def"
输出：0
解释：两个字符串没有公共子序列，返回 0 。
```

**提示：**

- `1 <= text1.length, text2.length <= 1000`
- `text1` 和 `text2` 仅由小写英文字符组成。

```go
func longestCommonSubsequence(text1 string, text2 string) int {
    m, n := len(text1), len(text2)
    dp := make([][]int, m + 1)
    for i := 0; i < m + 1; i++ {
        dp[i] = make([]int, n + 1)
    }
    for i := 1; i < m + 1; i++ {
        for j := 1; j < n + 1; j++ {
            if text1[i - 1] == text2[j - 1] {
                dp[i][j] = dp[i - 1][j - 1] + 1
            } else {
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
            }
        }
    }
    return dp[m][n]
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```

#### [115. 不同的子序列](https://leetcode-cn.com/problems/distinct-subsequences/)

给定一个字符串 `s` 和一个字符串 `t` ，计算在 `s` 的子序列中 `t` 出现的个数。

字符串的一个 **子序列** 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，`"ACE"` 是 `"ABCDE"` 的一个子序列，而 `"AEC"` 不是）

题目数据保证答案符合 32 位带符号整数范围。

**示例 1：**

```
输入：s = "rabbbit", t = "rabbit"
输出：3
解释：
如下图所示, 有 3 种可以从 s 中得到 "rabbit" 的方案。
(上箭头符号 ^ 表示选取的字母)
rabbbit
^^^^ ^^
rabbbit
^^ ^^^^
rabbbit
^^^ ^^^
```

**示例 2：**

```
输入：s = "babgbag", t = "bag"
输出：5
解释：
如下图所示, 有 5 种可以从 s 中得到 "bag" 的方案。 
(上箭头符号 ^ 表示选取的字母)
babgbag
^^ ^
babgbag
^^    ^
babgbag
^    ^^
babgbag
  ^  ^^
babgbag
    ^^^
```

**提示：**

- `0 <= s.length, t.length <= 1000`
- `s` 和 `t` 由英文字母组成

```go
/*
if t[i - 1] == s[j - 1] {
    dp[i][j] = dp[i - 1][j - 1] + dp[i][j - 1]
} else {
    dp[i][j] = dp[i][j - 1]
}
当对应位置不相等时，s就不用当前字符，可以很容易判断，次数就是除去当前s字符的个数；
当对应位置相等时，有两种情况：
1、使用当前相等的字符，结果也就是dp[i - 1][j - 1]；
2、不使用当前字符，与不相等时一样，dp[i][j - 1]
*/

func numDistinct(s string, t string) int {
    m, n := len(t), len(s)
    dp := make([][]int, m + 1)
    for i := 0; i < m + 1; i++ {
        dp[i] = make([]int, n + 1)
    }
    for i := 0; i < n + 1; i++ {
        dp[0][i] = 1
    }
    for i := 1; i < m + 1; i++ {
        for j := 1; j < n + 1; j++ {
            if t[i - 1] == s[j - 1] {
                dp[i][j] = dp[i - 1][j - 1] + dp[i][j - 1]
            } else {
                dp[i][j] = dp[i][j - 1]
            }
        }
    }
    return dp[m][n]
}
```

#### [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。

你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。

**示例 1：**

```
输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

**示例 2：**

```
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
```

**提示：**

- `1 <= prices.length <= 105`
- `0 <= prices[i] <= 104`

```go
func maxProfit(prices []int) int {
	minp := prices[0]
	ans := 0
	for i := 1; i < len(prices); i++ {
		ans = max(prices[i]-minp, ans)
		minp = min(prices[i], minp)
	}
	return ans
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```

#### [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

给定一个数组 `prices` ，其中 `prices[i]` 是一支给定股票第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例 1:**

```
输入: prices = [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
```

**示例 2:**

```
输入: prices = [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```

**示例 3:**

```
输入: prices = [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```

**提示：**

- `1 <= prices.length <= 3 * 104`
- `0 <= prices[i] <= 104`

```go
func maxProfit(prices []int) int {
    ans := 0
    for i := 1; i < len(prices); i++ {
        temp := prices[i] - prices[i - 1]
        if temp > 0 {
            ans += (temp)
        }
    }
    return ans
}

func max(a, b int) int {
	if a > b { return a }
	return b
}
```

#### [309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

给定一个整数数组，其中第 *i* 个元素代表了第 *i* 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

- 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
- 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

**示例:**

```
输入: [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
```

```go
func maxProfit(prices []int) int {
    dp := make([][]int, len(prices))
    for i := 0; i < len(prices); i++ {
        dp[i] = make([]int, 2)
    }
    dp[0][0] = 0
    dp[0][1] = -prices[0]
    for i := 1; i < len(prices); i++ {
        dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i])
        if i - 1 - 1 >= 0 {
            dp[i][1] = max(dp[i - 1][1], dp[i - 1 - 1][0] - prices[i])
        } else {
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i])
        }
    }
    return dp[len(prices) - 1][0]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### [714. 买卖股票的最佳时机含手续费](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

给定一个整数数组 `prices`，其中第 `i` 个元素代表了第 `i` 天的股票价格 ；非负整数 `fee` 代表了交易股票的手续费用。

你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。

返回获得利润的最大值。

**注意：**这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。

**示例 1:**

```
输入: prices = [1, 3, 2, 8, 4, 9], fee = 2
输出: 8
解释: 能够达到的最大利润:  
在此处买入 prices[0] = 1
在此处卖出 prices[3] = 8
在此处买入 prices[4] = 4
在此处卖出 prices[5] = 9
总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.
```

**注意:**

- `0 < prices.length <= 50000`.
- `0 < prices[i] < 50000`.
- `0 <= fee < 50000`.

```go
func maxProfit(prices []int, fee int) int {
    dp := make([][]int, len(prices))
    for i := 0; i < len(prices); i++ {
        dp[i] = make([]int, 2)
    }
    dp[0][0] = 0
    dp[0][1] = -prices[0] - fee
    for i := 1; i < len(prices); i++ {
        dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i])
        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i] - fee)
    }
    return dp[len(prices) - 1][0]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### [123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)

给定一个数组，它的第 `i` 个元素是一支给定的股票在第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 **两笔** 交易。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例 1:**

```
输入：prices = [3,3,5,0,0,3,1,4]
输出：6
解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
```

**示例 2：**

```
输入：prices = [1,2,3,4,5]
输出：4
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```

**示例 3：**

```
输入：prices = [7,6,4,3,1] 
输出：0 
解释：在这个情况下, 没有交易完成, 所以最大利润为 0。
```

**示例 4：**

```
输入：prices = [1]
输出：0
```

**提示：**

- `1 <= prices.length <= 105`
- `0 <= prices[i] <= 105`

```go
func maxProfit(prices []int) int {
    dp := make([][][]int, len(prices))
    for i := 0; i < len(prices); i++ {
        dp[i] = make([][]int, 2)
        for j := 0; j < 2; j++ {
            dp[i][j] = make([]int, 3)
        }
    }
    for k := 0; k < 3; k++ {
        dp[0][0][k] = 0
        dp[0][1][k] = -prices[0]
    }
    for i := 1; i < len(prices); i++ {
        dp[i][0][0] = 0
        dp[i][0][1] = max(dp[i - 1][0][1], dp[i - 1][1][0] + prices[i])
        dp[i][0][2] = max(dp[i - 1][0][2], dp[i - 1][1][1] + prices[i])
        dp[i][1][0] = max(dp[i - 1][1][0], dp[i - 1][0][0] - prices[i])
        dp[i][1][1] = max(dp[i - 1][1][1], dp[i - 1][0][1] - prices[i])
        dp[i][1][2] = 0
    }
    return max(dp[len(prices) - 1][0][1], dp[len(prices) - 1][0][2])
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### [188. 买卖股票的最佳时机 IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)

给定一个整数数组 `prices` ，它的第 `i` 个元素 `prices[i]` 是一支给定的股票在第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 **k** 笔交易。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例 1：**

```
输入：k = 2, prices = [2,4,1]
输出：2
解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。
```

**示例 2：**

```
输入：k = 2, prices = [3,2,6,5,0,3]
输出：7
解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。
     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。
```

**提示：**

- `0 <= k <= 100`
- `0 <= prices.length <= 1000`
- `0 <= prices[i] <= 1000`

```go
func maxProfit(kMax int, prices []int) int {
    if len(prices) < 2 {return 0}
    dp := make([][][]int, len(prices))
    for i := 0; i < len(prices); i++ {
        dp[i] = make([][]int, 2)
        for j := 0; j < 2; j++ {
            dp[i][j] = make([]int, kMax + 1)
        }
    }
    for i := 0; i <= kMax; i++ {
        dp[0][0][i] = 0
        dp[0][1][i] = -prices[0]
    }

    for i := 1; i < len(prices); i++ {
        for k := 0; k <= kMax; k++ {
            if k > 0 {
                dp[i][0][k] = max(dp[i - 1][0][k], dp[i - 1][1][k - 1] + prices[i])
            }
            dp[i][1][k] = max(dp[i - 1][1][k], dp[i - 1][0][k] - prices[i])
        }
        dp[i][0][0] = 0
        dp[i][1][kMax] = 0
    }
    ans := 0
    for k := 0; k <= kMax; k++ {
        if dp[len(prices) - 1][0][k] > ans {
            ans = dp[len(prices) - 1][0][k]
        }
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### [873. 最长的斐波那契子序列的长度](https://leetcode-cn.com/problems/length-of-longest-fibonacci-subsequence/)

如果序列 `X_1, X_2, ..., X_n` 满足下列条件，就说它是 *斐波那契式* 的：

- `n >= 3`
- 对于所有 `i + 2 <= n`，都有 `X_i + X_{i+1} = X_{i+2}`

给定一个**严格递增**的正整数数组形成序列，找到 `A` 中最长的斐波那契式的子序列的长度。如果一个不存在，返回 0 。

*（回想一下，子序列是从原序列 `A` 中派生出来的，它从 `A` 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， `[3, 5, 8]` 是 `[3, 4, 5, 6, 7, 8]` 的一个子序列）*

**示例 1：**

```
输入: [1,2,3,4,5,6,7,8]
输出: 5
解释:
最长的斐波那契式子序列为：[1,2,3,5,8] 。
```

**示例 2：**

```
输入: [1,3,7,11,12,14,18]
输出: 3
解释:
最长的斐波那契式子序列有：
[1,11,12]，[3,11,14] 以及 [7,11,18] 。
```

**提示：**

- `3 <= A.length <= 1000`
- `1 <= A[0] < A[1] < ... < A[A.length - 1] <= 10^9`

```go
func lenLongestFibSubseq(A []int) int {
	N := len(A)
	index := map[int]int{}
	for i, num := range A {
		index[num] = i
	}
	dp := make([][]int, N)
	for i := 0; i < N; i++ {
		dp[i] = make([]int, N)
	}
	var ans int
	for i := 0; i < N; i++ {
		for j := 0; j < i; j++ {
			idx, ok := index[A[i]-A[j]]
			if A[i]-A[j] < A[j] && ok {
				dp[j][i] = dp[idx][j] + 1
				ans = max(ans, dp[j][i]+2)
			}
		}
	}

	if ans >= 3 {
		return ans
	}
	return 0
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```

#### [1027. 最长等差数列](https://leetcode-cn.com/problems/longest-arithmetic-subsequence/)

给定一个整数数组 `A`，返回 `A` 中最长等差子序列的**长度**。

回想一下，`A` 的子序列是列表 `A[i_1], A[i_2], ..., A[i_k]` 其中 `0 <= i_1 < i_2 < ... < i_k <= A.length - 1`。并且如果 `B[i+1] - B[i]`( `0 <= i < B.length - 1`) 的值都相同，那么序列 `B` 是等差的。

**示例 1：**

```
输入：[3,6,9,12]
输出：4
解释： 
整个数组是公差为 3 的等差数列。
```

**示例 2：**

```
输入：[9,4,7,2,10]
输出：3
解释：
最长的等差子序列是 [4,7,10]。
```

**示例 3：**

```
输入：[20,1,15,3,10,5,8]
输出：4
解释：
最长的等差子序列是 [20,15,10,5]。
```

**提示：**

1. `2 <= A.length <= 2000`
2. `0 <= A[i] <= 10000`

```go
func longestArithSeqLength(arr []int) int {
	n := len(arr)
	dp := make([]map[int]int, n)
	for i := 0; i < n; i++ {
		dp[i] = map[int]int{}
	}
	var ans int
	for i := 0; i < n; i++ {
		for j := 0; j < i; j++ {
			diff := arr[i] - arr[j]
			dp[i][diff] = max(dp[j][diff]+1, dp[i][diff])
			ans = max(ans, dp[i][diff])
		}
	}
	return ans + 1
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```

#### [368. 最大整除子集](https://leetcode-cn.com/problems/largest-divisible-subset/)

给你一个由 **无重复** 正整数组成的集合 `nums` ，请你找出并返回其中最大的整除子集 `answer` ，子集中每一元素对 `(answer[i], answer[j])` 都应当满足：

- `answer[i] % answer[j] == 0` ，或
- `answer[j] % answer[i] == 0`

如果存在多个有效解子集，返回其中任何一个均可。

**示例 1：**

```
输入：nums = [1,2,3]
输出：[1,2]
解释：[1,3] 也会被视为正确答案。
```

**示例 2：**

```
输入：nums = [1,2,4,8]
输出：[1,2,4,8]
```

**提示：**

- `1 <= nums.length <= 1000`
- `1 <= nums[i] <= 2 * 109`
- `nums` 中的所有整数 **互不相同**

```go
func largestDivisibleSubset(arr []int) []int {
	sort.Ints(arr)
	n := len(arr)
	dp := make([]int, n)
	from := make([]int, n)
	maxIdx := 0
	length := 0
	for i := 0; i < n; i++ {
		from[i] = i
		for j := 0; j < i; j++ {
			if arr[i]%arr[j] == 0 {
				if dp[j]+1 > dp[i] {
					dp[i] = dp[j] + 1
					from[i] = j
				}
				if dp[i] > length {
					length = dp[i]
					maxIdx = i
				}
			}

		}
	}
	ans := []int{}
	idx := maxIdx
	for {
		ans = append(ans, arr[idx])
		if idx == from[idx] {
			break
		}
		idx = from[idx]
	}
	return ans
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```

#### [413. 等差数列划分](https://leetcode-cn.com/problems/arithmetic-slices/)

如果一个数列至少有三个元素，并且任意两个相邻元素之差相同，则称该数列为等差数列。

例如，以下数列为等差数列:

```
1, 3, 5, 7, 9
7, 7, 7, 7
3, -1, -5, -9
```

以下数列不是等差数列。

```
1, 1, 2, 5, 7
```

数组 A 包含 N 个数，且索引从0开始。数组 A 的一个子数组划分为数组 (P, Q)，P 与 Q 是整数且满足 0<=P<Q<N 。

如果满足以下条件，则称子数组(P, Q)为等差数组：

元素 A[P], A[p + 1], ..., A[Q - 1], A[Q] 是等差的。并且 P + 1 < Q 。

函数要返回数组 A 中所有为等差数组的子数组个数。

**示例:**

```
A = [1, 2, 3, 4]

返回: 3, A 中有三个子等差数组: [1, 2, 3], [2, 3, 4] 以及自身 [1, 2, 3, 4]。
```

```go
func numberOfArithmeticSlices(nums []int) int {
    n := len(nums)
    var ans int
    dp := make([]int, n)
    for i := 2; i < n; i++ {
        if nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2] {
            dp[i] = dp[i - 1] + 1
            ans += dp[i]
        }
    }
    return ans
}
```

#### [91. 解码方法](https://leetcode-cn.com/problems/decode-ways/)

一条包含字母 `A-Z` 的消息通过以下映射进行了 **编码** ：

```
'A' -> 1
'B' -> 2
...
'Z' -> 26
```

要 **解码** 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，`"11106"` 可以映射为：

- `"AAJF"` ，将消息分组为 `(1 1 10 6)`
- `"KJF"` ，将消息分组为 `(11 10 6)`

注意，消息不能分组为 `(1 11 06)` ，因为 `"06"` 不能映射为 `"F"` ，这是由于 `"6"` 和 `"06"` 在映射中并不等价。

给你一个只含数字的 **非空** 字符串 `s` ，请计算并返回 **解码** 方法的 **总数** 。

题目数据保证答案肯定是一个 **32 位** 的整数。

**示例 1：**

```
输入：s = "12"
输出：2
解释：它可以解码为 "AB"（1 2）或者 "L"（12）。
```

**示例 2：**

```
输入：s = "226"
输出：3
解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
```

**示例 3：**

```
输入：s = "0"
输出：0
解释：没有字符映射到以 0 开头的数字。
含有 0 的有效映射是 'J' -> "10" 和 'T'-> "20" 。
由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。
```

**示例 4：**

```
输入：s = "06"
输出：0
解释："06" 不能映射到 "F" ，因为字符串含有前导 0（"6" 和 "06" 在映射中并不等价）。
```

**提示：**

- `1 <= s.length <= 100`
- `s` 只包含数字，并且可能包含前导零。

```go
func numDecodings(s string) int {
    if s[0] == '0' { return 0 }
    dp := make([]int, len(s) + 1)
    dp[0] = 1
    dp[1] = 1
    for i := 2; i < len(s) + 1; i++ {
        if s[i - 1] == '0' {
            if s[i - 2] == '0' || s[i - 2] > '2' { return 0 }
            dp[i] = dp[i - 2]
            continue
        }
        if s[i - 2] == '1' || (s[i - 2] == '2' && s[i - 1] < '7') {
            dp[i] = dp[i - 1] + dp[i - 2]
        } else {
            dp[i] = dp[i - 1]
        }
    }
    return dp[len(s)]
```

#### [338. 比特位计数](https://leetcode-cn.com/problems/counting-bits/)

给定一个非负整数 **num**。对于 **0 ≤ i ≤ num** 范围中的每个数字 **i** ，计算其二进制数中的 1 的数目并将它们作为数组返回。

**示例 1:**

```
输入: 2
输出: [0,1,1]
```

**示例 2:**

```
输入: 5
输出: [0,1,1,2,1,2]
```

**进阶:**

- 给出时间复杂度为**O(n\*sizeof(integer))**的解答非常容易。但你可以在线性时间**O(n)**内用一趟扫描做到吗？
- 要求算法的空间复杂度为**O(n)**。
- 你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 **__builtin_popcount**）来执行此操作。

```go
func countBits(num int) []int {
    dp := make([]int, num+1)
	for i := 1; i <= num; i++ {
		if i&1 == 1 {
			dp[i] = dp[i-1] + 1
		} else {
			dp[i] = dp[i>>1]
		}
	}
	return dp
}
```

#### [583. 两个字符串的删除操作](https://leetcode-cn.com/problems/delete-operation-for-two-strings/)

给定两个单词 *word1* 和 *word2*，找到使得 *word1* 和 *word2* 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。

**示例：**

```
输入: "sea", "eat"
输出: 2
解释: 第一步将"sea"变为"ea"，第二步将"eat"变为"ea"
```

**提示：**

1. 给定单词的长度不超过500。
2. 给定单词中的字符只含有小写字母。

```go
func minDistance(word1 string, word2 string) int {
    m, n := len(word1), len(word2)
    dp := make([][]int, m + 1)
    for i := 0; i < m + 1; i++ {
        dp[i] = make([]int, n + 1)
        dp[i][0] = i
    }
    for i := 0; i < n + 1; i++ {
        dp[0][i] = i
    }
    for i := 1; i < m + 1; i++ {
        for j := 1; j < n + 1; j++ {
            if word1[i - 1] == word2[j - 1] {
                dp[i][j] = dp[i - 1][j - 1]
            } else {
                dp[i][j] = min(min(dp[i - 1][j - 1] + 2, dp[i - 1][j] + 1), dp[i][j - 1] + 1)
            }
        }
    }
    return dp[m][n]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}

```

#### [32. 最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)

给你一个只包含 `'('` 和 `')'` 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

**示例 1：**

```
输入：s = "(()"
输出：2
解释：最长有效括号子串是 "()"
```

**示例 2：**

```
输入：s = ")()())"
输出：4
解释：最长有效括号子串是 "()()"
```

**示例 3：**

```
输入：s = ""
输出：0
```

**提示：**

- `0 <= s.length <= 3 * 104`
- `s[i]` 为 `'('` 或 `')'`

```go
func longestValidParentheses(s string) int {
    l := len(s)
    dp := make([]int, l)
    ans := 0
    for i := 1; i < l; i++ {
        if s[i] == ')' {
            if s[i-1] == '(' {
                if i-2 < 0 {
                    dp[i] = 2
                } else {
                    dp[i] = 2 + dp[i-2]
                }
            } else if dp[i-1] > 0 {
                if i - dp[i-1] - 1 >= 0 && s[i - dp[i-1] - 1] == '(' {
                    if i - dp[i-1] - 2 < 0 {
                        dp[i] = dp[i - 1] + 2
                    } else {
                        dp[i] = dp[i - dp[i-1] - 2] + 2 + dp[i - 1]
                    }
                }
            }
        }
        ans = max(ans, dp[i])
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### [132. 分割回文串 II](https://leetcode-cn.com/problems/palindrome-partitioning-ii/)

给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是回文。

返回符合要求的 **最少分割次数** 。

**示例 1：**

```
输入：s = "aab"
输出：1
解释：只需一次分割就可将 s 分割成 ["aa","b"] 这样两个回文子串。
```

**示例 2：**

```
输入：s = "a"
输出：0
```

**示例 3：**

```
输入：s = "ab"
输出：1
```

**提示：**

- `1 <= s.length <= 2000`
- `s` 仅由小写英文字母组成

```go
func minCut(s string) int {
    l := len(s)
    if l < 2 { return 0 }
    isPali := make([][]bool, l)
    for i := 0; i < l; i++ {
        isPali[i] = make([]bool, l)
        isPali[i][i] = true
    }
    for j := 0; j < l; j++ {
        for i := j - 1; i >= 0; i-- {
            if s[i] == s[j] {
                if j - i == 1 {
                    isPali[i][j] = true
                } else {
                    isPali[i][j] = isPali[i + 1][j - 1]
                }
            }
        } 
    }
    dp := make([]int, l)
    for j := 0; j < l; j++ {
        dp[j] = j
    }
    for j := 0; j < l; j++ {
        if isPali[0][j] == true {
            dp[j] = 0
            continue
        }
        for i := 1; i <= j; i++ {
            if isPali[i][j] {
                dp[j] = min(dp[j], dp[i - 1] + 1)
            }
        }
    }
    return dp[l - 1]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

#### [871. 最低加油次数](https://leetcode-cn.com/problems/minimum-number-of-refueling-stops/)

汽车从起点出发驶向目的地，该目的地位于出发位置东面 `target` 英里处。

沿途有加油站，每个 `station[i]` 代表一个加油站，它位于出发位置东面 `station[i][0]` 英里处，并且有 `station[i][1]` 升汽油。

假设汽车油箱的容量是无限的，其中最初有 `startFuel` 升燃料。它每行驶 1 英里就会用掉 1 升汽油。

当汽车到达加油站时，它可能停下来加油，将所有汽油从加油站转移到汽车中。

为了到达目的地，汽车所必要的最低加油次数是多少？如果无法到达目的地，则返回 `-1` 。

注意：如果汽车到达加油站时剩余燃料为 0，它仍然可以在那里加油。如果汽车到达目的地时剩余燃料为 0，仍然认为它已经到达目的地。

**示例 1：**

```
输入：target = 1, startFuel = 1, stations = []
输出：0
解释：我们可以在不加油的情况下到达目的地。
```

**示例 2：**

```
输入：target = 100, startFuel = 1, stations = [[10,100]]
输出：-1
解释：我们无法抵达目的地，甚至无法到达第一个加油站。
```

**示例 3：**

```
输入：target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]]
输出：2
解释：
我们出发时有 10 升燃料。
我们开车来到距起点 10 英里处的加油站，消耗 10 升燃料。将汽油从 0 升加到 60 升。
然后，我们从 10 英里处的加油站开到 60 英里处的加油站（消耗 50 升燃料），
并将汽油从 10 升加到 50 升。然后我们开车抵达目的地。
我们沿途在1两个加油站停靠，所以返回 2 。
```

**提示：**

1. `1 <= target, startFuel, stations[i][1] <= 10^9`
2. `0 <= stations.length <= 500`
3. `0 < stations[0][0] < stations[1][0] < ... < stations[stations.length-1][0] < target`

```go
func minRefuelStops(target int, startFuel int, stations [][]int) int {
    l := len(stations)
    dp := make([]int, l + 1)
    dp[0] = startFuel
    for i := 1; i <= l; i++ {
    	// 只能i->0，不能i->l；因为i必须从左到右，如果后一种有可能出现，先到i较大的位置，再到i较小的位置。
        for j := i; j > 0; j-- {
            if dp[j - 1] >= stations[i - 1][0] {
                dp[j] = max(dp[j], dp[j - 1] + stations[i - 1][1])
            }
        }
    }
    fmt.Println(dp)
    for i := 0; i <= l; i++ {
        if dp[i] >= target {
            return i
        }
    }
    
    return -1
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### [120. 三角形最小路径和](https://leetcode-cn.com/problems/triangle/)

给定一个三角形 `triangle` ，找出自顶向下的最小路径和。

每一步只能移动到下一行中相邻的结点上。**相邻的结点** 在这里指的是 **下标** 与 **上一层结点下标** 相同或者等于 **上一层结点下标 + 1** 的两个结点。也就是说，如果正位于当前行的下标 `i` ，那么下一步可以移动到下一行的下标 `i` 或 `i + 1` 。

**示例 1**

```
输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
输出：11
解释：如下面简图所示：
   2
  3 4
 6 5 7
4 1 8 3
自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。
```

**示例 2：**

```
输入：triangle = [[-10]]
输出：-10
```

**提示：**

- `1 <= triangle.length <= 200`
- `triangle[0].length == 1`
- `triangle[i].length == triangle[i - 1].length + 1`
- `-104 <= triangle[i][j] <= 104`

**进阶：**

- 你可以只使用 `O(n)` 的额外空间（`n` 为三角形的总行数）来解决这个问题吗？

```go
func minimumTotal(triangle [][]int) int {
    dp := make([][]int, len(triangle))
    for i := 0; i < len(triangle); i++ {
        dp[i] = make([]int, len(triangle[i]))
        copy(dp[i], triangle[i])
    }
    for i := len(triangle) - 2; i >= 0; i-- {
        for j := 0; j < len(triangle[i]); j++ {
            dp[i][j] = min(dp[i + 1][j], dp[i + 1][j + 1]) + dp[i][j]
        }
    }
    return dp[0][0]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

#### [64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)

给定一个包含非负整数的 `m x n` 网格 `grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**说明：**每次只能向下或者向右移动一步。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg)

```
输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
输出：7
解释：因为路径 1→3→1→1→1 的总和最小。
```

**示例 2：**

```
输入：grid = [[1,2,3],[4,5,6]]
输出：12
```

**提示：**

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 200`
- `0 <= grid[i][j] <= 100`

```go
func minPathSum(grid [][]int) int {
    dp := make([][]int, len(grid))
    for i := 0; i < len(grid); i++ {
        dp[i] = make([]int, len(grid[0]))
    }
    dp[0][0] = grid[0][0]
    for i := 1; i < len(grid); i++ {
        dp[i][0] = grid[i][0] + dp[i - 1][0]
    }
    for j := 1; j < len(grid[0]); j++ {
        dp[0][j] = grid[0][j] + dp[0][j - 1]
    }

    for i := 1; i < len(grid); i++ {
        for j := 1; j < len(grid[0]); j++ {
            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]
        }
    }
    return dp[len(grid) - 1][len(grid[0]) - 1]

}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

#### [221. 最大正方形](https://leetcode-cn.com/problems/maximal-square/)

在一个由 `'0'` 和 `'1'` 组成的二维矩阵内，找到只包含 `'1'` 的最大正方形，并返回其面积。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/26/max1grid.jpg)

```
输入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
输出：4
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/11/26/max2grid.jpg)

```
输入：matrix = [["0","1"],["1","0"]]
输出：1
```

**示例 3：**

```
输入：matrix = [["0"]]
输出：0
```

**提示：**

- `m == matrix.length`
- `n == matrix[i].length`
- `1 <= m, n <= 300`
- `matrix[i][j]` 为 `'0'` 或 `'1'`

```go
func maximalSquare(matrix [][]byte) int {
    m, n := len(matrix), len(matrix[0])
    dp := make([][]int, m)
    for i := 0; i < m; i++ {
        dp[i] = make([]int, n)
    }
    ans := 0
    for i := 0; i < m; i++ {
        dp[i][0] = int(matrix[i][0] - '0')
        ans = max(ans, dp[i][0])
    }
    for i := 0; i < n; i++ {
        dp[0][i] = int(matrix[0][i] - '0')
        ans = max(ans, dp[0][i])
    }
    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            if matrix[i][j] == '1' {
                dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1], dp[i][j - 1]) + 1
                ans = max(dp[i][j], ans)
            }
            
        }
    }
    return ans * ans
}

func min(a, b, c int) int {
    ans := a
    if b < ans {
        ans = b
    }
    if c < ans {
        ans = c
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### [343. 整数拆分](https://leetcode-cn.com/problems/integer-break/)

给定一个正整数 *n*，将其拆分为**至少**两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。

**示例 1:**

```
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。
```

**示例 2:**

```
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
```

**说明:** 你可以假设 *n* 不小于 2 且不大于 58。

```go
func integerBreak(n int) int {
    dp := make([]int, n + 1)
    for i := 2; i <= n; i++ {
        curMax := 0
        for j := 1; j < i; j++ {
            curMax = max(curMax, max(j * (i - j), j * dp[i - j]))
        }
        dp[i] = curMax
    }
    return dp[n]
}

func max(x, y int) int {
    if x > y {
        return x
    }
    return y
}
```

也可以使用数学方法。

#### [363. 矩形区域不超过 K 的最大数值和](https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/)

给你一个 `m x n` 的矩阵 `matrix` 和一个整数 `k` ，找出并返回矩阵内部矩形区域的不超过 `k` 的最大数值和。

题目数据保证总会存在一个数值和不超过 `k` 的矩形区域。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/03/18/sum-grid.jpg)

```
输入：matrix = [[1,0,1],[0,-2,3]], k = 2
输出：2
解释：蓝色边框圈出来的矩形区域 [[0, 1], [-2, 3]] 的数值和是 2，且 2 是不超过 k 的最大数字（k = 2）。
```

**示例 2：**

```
输入：matrix = [[2,2,-1]], k = 3
输出：3
```

**提示：**

- `m == matrix.length`
- `n == matrix[i].length`
- `1 <= m, n <= 100`
- `-100 <= matrix[i][j] <= 100`
- `-105 <= k <= 105`

**进阶：**如果行数远大于列数，该如何设计解决方案？

```go
func maxSumSubmatrix(mat [][]int, k int) int {
    m, n := len(mat), len(mat[0])
    sum := make([][]int, m + 1)
    for i := 0; i < m + 1; i++ {
        sum[i] = make([]int, n + 1)
    }
    // 先将sum构造成前缀和。
    for i := 1; i < m + 1; i++ {
        for j := 1; j < n + 1; j++ {
            sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + mat[i - 1][j - 1]
        }
    }
    ans := math.MinInt32
    for i := 1; i < m + 1; i++ {
        for j := 1; j < n + 1; j++ {
            for p := i; p < m + 1; p++ {
                for q := j; q < n + 1; q++ {
                    cur := sum[p][q] - sum[i - 1][q] - sum[p][j - 1] + sum[i - 1][j - 1]
                    if cur <= k {
                        ans = max(ans, cur)
                    }
                }
            }
        }
    }
    return ans
}

func max(x, y int) int {
    if x > y {
        return x
    }
    return y
}
```

#### [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

给你一个字符串 `s`，找到 `s` 中最长的回文子串。

**示例 1：**

```
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
```

**示例 2：**

```
输入：s = "cbbd"
输出："bb"
```

**示例 3：**

```
输入：s = "a"
输出："a"
```

**示例 4：**

```
输入：s = "ac"
输出："a"
```

**提示：**

- `1 <= s.length <= 1000`
- `s` 仅由数字和英文字母（大写和/或小写）组成

```go
func longestPalindrome(s string) string {
	length := len(s)
	maxLen := 0
	idxs := [2]int{0,0}
	dp := make([][]int, length)
	for i:=0; i<length; i++ {
		dp[i] = make([]int, length)
		dp[i][i] = 1
	}

	for j:=1; j<length; j++ {
		for i:=0; i<j; i++ {
			if s[i] == s[j] {
				if j - i <= 2 {
					dp[i][j] = j - i + 1
				} else if dp[i + 1][j - 1] != 0 {
					dp[i][j] = dp[i + 1][j - 1] + 2
				}
			}
			if dp[i][j] > maxLen {
				maxLen = dp[i][j]
				idxs[0] = i
				idxs[1] = j
			}
		}
	}
	return s[idxs[0]:idxs[1]+1]
}
```

#### [647. 回文子串](https://leetcode-cn.com/problems/palindromic-substrings/)

给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。

具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。

**示例 1：**

```
输入："abc"
输出：3
解释：三个回文子串: "a", "b", "c"
```

**示例 2：**

```
输入："aaa"
输出：6
解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"
```

**提示：**

- 输入的字符串长度不会超过 1000 。

```go
func countSubstrings(s string) int {
	length := len(s)
	ans := 0
	dp := make([][]bool, length)
	for i:=0; i<length; i++ {
		dp[i] = make([]bool, length)
		dp[i][i] = true
		ans++
	}

	for j:=1; j<length; j++ {
		for i:=0; i<j; i++ {
			dp[i][j] = false
			if s[i] == s[j] {
				if j - i <= 2 || dp[i + 1][j - 1] == true {
					dp[i][j] = true
					ans++
				}
			}
		}
	}
	return ans
}
```

#### [516. 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)

给定一个字符串 `s` ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 `s` 的最大长度为 `1000` 。

**示例 1:**
输入:

```
"bbbab"
```

输出:

```
4
```

一个可能的最长回文子序列为 "bbbb"。

**示例 2:**
输入:

```
"cbbd"
```

输出:

```
2
```

一个可能的最长回文子序列为 "bb"。

**提示：**

- `1 <= s.length <= 1000`
- `s` 只包含小写英文字母

```go
func longestPalindromeSubseq(s string) int {
	length := len(s)
	dp := make([][]int, length)
	for i:=0; i<length; i++ {
		dp[i] = make([]int, length)
		dp[i][i] = 1
	}

	for j:=1; j<length; j++ {
		for i:=j-1; i>=0; i-- {
			if s[i] == s[j] {
				dp[i][j] = dp[i + 1][j - 1] + 2
			} else {
				dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])
			}
		}
	}
	return dp[0][length - 1]
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```

#### [312. 戳气球](https://leetcode-cn.com/problems/burst-balloons/)

有 `n` 个气球，编号为`0` 到 `n - 1`，每个气球上都标有一个数字，这些数字存在数组 `nums` 中。

现在要求你戳破所有的气球。戳破第 `i` 个气球，你可以获得 `nums[i - 1] * nums[i] * nums[i + 1]` 枚硬币。 这里的 `i - 1` 和 `i + 1` 代表和 `i` 相邻的两个气球的序号。如果 `i - 1`或 `i + 1` 超出了数组的边界，那么就当它是一个数字为 `1` 的气球。

求所能获得硬币的最大数量。

**示例 1：**

```
输入：nums = [3,1,5,8]
输出：167
解释：
nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> []
coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167
```

**示例 2：**

```
输入：nums = [1,5]
输出：10
```

**提示**

- `n == nums.length`
- `1 <= n <= 500`
- `0 <= nums[i] <= 100`

```go
func maxCoins(nums []int) int {
	if len(nums) == 0 { return 0 }
	arr := []int{1}
	arr = append(arr, nums...)
	arr = append(arr, 1)

	length := len(arr)
	// dp[i][j]表示从i到j的最大值
	dp := make([][]int, length)
	for i := 0; i < length; i++ {
		dp[i] = make([]int, length)
	}
	ans := 0
	// n表示i~j的长度
	for n := 2; n < length + 1; n++ {
		// 气球范围是[i, j]，k是中间分界线，最终，k = i + 1, k = j - 1
		for i := 0; i < length - n; i++ {
			j := i + n
			// k是分界线，
			for k := i + 1; k < j; k++ {
				dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + arr[i] * arr[j] * arr[k])
			}
			ans = max(dp[i][j], ans)
		}
	}
	return ans
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

```

#### [546. 移除盒子](https://leetcode-cn.com/problems/remove-boxes/)

给出一些不同颜色的盒子，盒子的颜色由数字表示，即不同的数字表示不同的颜色。

你将经过若干轮操作去去掉盒子，直到所有的盒子都去掉为止。每一轮你可以移除具有相同颜色的连续 `k` 个盒子（`k >= 1`），这样一轮之后你将得到 `k * k` 个积分。

当你将所有盒子都去掉之后，求你能获得的最大积分和。

**示例 1：**

```
输入：boxes = [1,3,2,2,2,3,4,3,1]
输出：23
解释：
[1, 3, 2, 2, 2, 3, 4, 3, 1] 
----> [1, 3, 3, 4, 3, 1] (3*3=9 分) 
----> [1, 3, 3, 3, 1] (1*1=1 分) 
----> [1, 1] (3*3=9 分) 
----> [] (2*2=4 分)
```

**示例 2：**

```
输入：boxes = [1,1,1]
输出：9
```

**示例 3：**

```
输入：boxes = [1]
输出：1
```

**提示：**

- `1 <= boxes.length <= 100`
- `1 <= boxes[i] <= 100`

```go
func removeBoxes(boxes []int) int {
	length := len(boxes)
	dp := make([][][]int, length)
	for i := 0; i < length; i++ {
		dp[i] = make([][]int, length)
		for j := 0; j < length; j++ {
			dp[i][j] = make([]int, length)
		}
	}

	for n := 0; n < length; n++ {
		for i := 0; i < length - n; i++ {
			j := i + n
			for t := 0; t < length - j; t++ {
				if j == 0 {
					dp[i][j][t] = max(dp[i][j][t], (t + 1)*(t + 1))
				} else {
					dp[i][j][t] = max(dp[i][j][t], (t + 1)*(t + 1) + dp[i][j - 1][0])
				}
				for k := i; k < j; k++ {
					if boxes[k] == boxes[j] {
						dp[i][j][t] = max(dp[i][j][t], dp[i][k][t + 1] + dp[k + 1][j - 1][0])
					}
				}
			}
		}
	}
	return dp[0][length - 1][0]
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

```

#### [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

给定不同面额的硬币 `coins` 和一个总金额 `amount`。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 `-1`。

你可以认为每种硬币的数量是无限的。

**示例 1：**

```
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
```

**示例 2：**

```
输入：coins = [2], amount = 3
输出：-1
```

**示例 3：**

```
输入：coins = [1], amount = 0
输出：0
```

**示例 4：**

```
输入：coins = [1], amount = 1
输出：1
```

**示例 5：**

```
输入：coins = [1], amount = 2
输出：2
```

**提示：**

- `1 <= coins.length <= 12`
- `1 <= coins[i] <= 231 - 1`
- `0 <= amount <= 104`

```go
func coinChange(coins []int, amount int) int {
    dp := make([]int, amount + 1)
    for i := 0; i < amount + 1; i++ {
        dp[i] = amount + 1
    }
    dp[0] = 0
    for i := 1; i < amount + 1; i++ {
        for j := 0; j < len(coins); j++ {
            if coins[j] <= i {
                dp[i] = min(dp[i], dp[i - coins[j]] + 1)
            }
        }
    }
    if dp[amount] > amount {
        return -1
    }
    return dp[amount]
}

func min(x, y int) int {
    if x < y {
        return x
    }
    return y
}
```

#### [518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)

给你一个整数数组 `coins` 表示不同面额的硬币，另给一个整数 `amount` 表示总金额。

请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 `0` 。

假设每一种面额的硬币有无限个。 

题目数据保证结果符合 32 位带符号整数。

**示例 1：**

```
输入：amount = 5, coins = [1, 2, 5]
输出：4
解释：有四种方式可以凑成总金额：
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
```

**示例 2：**

```
输入：amount = 3, coins = [2]
输出：0
解释：只用面额 2 的硬币不能凑成总金额 3 。
```

**示例 3：**

```
输入：amount = 10, coins = [10] 
输出：1
```

**提示：**

- `1 <= coins.length <= 300`
- `1 <= coins[i] <= 5000`
- `coins` 中的所有值 **互不相同**
- `0 <= amount <= 5000`

```go
func change(amount int, coins []int) int {
    if amount == 0 { return 1 }
    dp := make([][]int, len(coins) + 1)
    sort.Ints(coins)
    for i := 0; i < len(coins) + 1; i++ {
        dp[i] = make([]int, amount + 1)
    }
    for i := 1; i < len(coins) + 1; i++ {
        if coins[i - 1] > amount { break }
        dp[i][coins[i - 1]] = 1
    }
    for i := 1; i < len(coins) + 1; i++ {
        if coins[i - 1] > amount {
            if i == 0 { return 0 }
            return dp[i - 1][amount]
        }
        for j := 1; j < amount + 1; j++ {
            dp[i][j] = dp[i][j] + dp[i - 1][j]
            if j > coins[i - 1] {
                dp[i][j] = dp[i][j] + dp[i][j - coins[i - 1]]
            }
        }
    }
    return dp[len(coins)][amount]

}
```

#### [1049. 最后一块石头的重量 II](https://leetcode-cn.com/problems/last-stone-weight-ii/)

有一堆石头，用整数数组 `stones` 表示。其中 `stones[i]` 表示第 `i` 块石头的重量。

每一回合，从中选出**任意两块石头**，然后将它们一起粉碎。假设石头的重量分别为 `x` 和 `y`，且 `x <= y`。那么粉碎的可能结果如下：

- 如果 `x == y`，那么两块石头都会被完全粉碎；
- 如果 `x != y`，那么重量为 `x` 的石头将会完全粉碎，而重量为 `y` 的石头新重量为 `y-x`。

最后，**最多只会剩下一块** 石头。返回此石头 **最小的可能重量** 。如果没有石头剩下，就返回 `0`。

**示例 1：**

```
输入：stones = [2,7,4,1,8,1]
输出：1
解释：
组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，
组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，
组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，
组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。
```

**示例 2：**

```
输入：stones = [31,26,33,21,40]
输出：5
```

**示例 3：**

```
输入：stones = [1,2]
输出：1
```

**提示：**

- `1 <= stones.length <= 30`
- `1 <= stones[i] <= 100`

```go
func lastStoneWeightII(stones []int) int {
	sum := 0
	for _, i := range stones {
		sum += i
	}

	halfSum := sum / 2
	dp := make([][]int, len(stones) + 1)
	for i:=0; i<len(stones)+1; i++ {
		dp[i] = make([]int, halfSum + 1)
	}
	for i:=1; i<len(stones)+1; i++ {
		for j:=1; j<halfSum+1; j++ {
			weight := stones[i - 1]
			if weight > j {
				dp[i][j] = dp[i-1][j]
			} else {
				dp[i][j] = max(dp[i-1][j], dp[i - 1][j - weight] + weight)
			}
		}
	}
	return sum - dp[len(stones)][halfSum] * 2
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```

#### [474. 一和零](https://leetcode-cn.com/problems/ones-and-zeroes/)

给你一个二进制字符串数组 `strs` 和两个整数 `m` 和 `n` 。

请你找出并返回 `strs` 的最大子集的大小，该子集中 **最多** 有 `m` 个 `0` 和 `n` 个 `1` 。

如果 `x` 的所有元素也是 `y` 的元素，集合 `x` 是集合 `y` 的 **子集** 。

**示例 1：**

```
输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
输出：4
解释：最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 。
其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。
```

**示例 2：**

```
输入：strs = ["10", "0", "1"], m = 1, n = 1
输出：2
解释：最大的子集是 {"0", "1"} ，所以答案是 2 。
```

**提示：**

- `1 <= strs.length <= 600`
- `1 <= strs[i].length <= 100`
- `strs[i]` 仅由 `'0'` 和 `'1'` 组成
- `1 <= m, n <= 100`

```go
func findMaxForm(strs []string, m int, n int) int {
	sNum := len(strs)
	dp := make([][][]int, sNum + 1)
	for i := 0; i < sNum + 1; i++ {
		dp[i] = make([][]int, m + 1)
		for j := 0; j < m + 1; j++ {
			dp[i][j] = make([]int, n + 1)
		}
	}

	count := func(str string) (c0, c1 int) {
		for _, s := range str {
			if s == '0' {
				c0++
			} else {
				c1++
			}
		}
		return
	}

	for i := 1; i < sNum + 1; i++ {
		c0, c1 := count(strs[i - 1])
		for j := 0; j < m + 1; j++ {
			for k := 0; k < n + 1; k++ {
				dp[i][j][k] = dp[i - 1][j][k]
				if j >= c0 && k >= c1 {
					dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - c0][k - c1] + 1)
				}
			}
		}
	}
	return dp[sNum][m][n]
}

func max(a, b int) int {
	if a > b { return a }
	return b
}
```

#### [494. 目标和](https://leetcode-cn.com/problems/target-sum/)

给你一个整数数组 `nums` 和一个整数 `target` 。

向数组中的每个整数前添加 `'+'` 或 `'-'` ，然后串联起所有整数，可以构造一个 **表达式** ：

- 例如，`nums = [2, 1]` ，可以在 `2` 之前添加 `'+'` ，在 `1` 之前添加 `'-'` ，然后串联起来得到表达式 `"+2-1"` 。

返回可以通过上述方法构造的、运算结果等于 `target` 的不同 **表达式** 的数目。

**示例 1：**

```
输入：nums = [1,1,1,1,1], target = 3
输出：5
解释：一共有 5 种方法让最终目标和为 3 。
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3
```

**示例 2：**

```
输入：nums = [1], target = 1
输出：1
```

**提示：**

- `1 <= nums.length <= 20`
- `0 <= nums[i] <= 1000`
- `0 <= sum(nums[i]) <= 1000`
- `-1000 <= target <= 1000`

```go
func findTargetSumWays(nums []int, target int) int {
	var sum int
    for _, num := range nums {
        sum += num
    }
    if target > sum { return 0 }
    dp := make([][]int, len(nums) + 1)
    for i := 0; i < len(nums) + 1; i++ {
        dp[i] = make([]int, 2 * sum + 1)
    }
    dp[0][sum] = 1
    for i := 1; i < len(nums) + 1; i++ {
        x := nums[i - 1]
        for j := 0; j <= 2 * sum; j++ {
            if j - x >= 0 { dp[i][j] += dp[i - 1][j - x] }
            if j + x <= 2 * sum { dp[i][j] += dp[i - 1][j + x] }
        }
    }
    return dp[len(nums)][target + sum]
}
```

#### [377. 组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv/)

给你一个由 **不同** 整数组成的数组 `nums` ，和一个目标整数 `target` 。请你从 `nums` 中找出并返回总和为 `target` 的元素组合的个数。

题目数据保证答案符合 32 位整数范围。

**示例 1：**

```
输入：nums = [1,2,3], target = 4
输出：7
解释：
所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
请注意，顺序不同的序列被视作不同的组合。
```

**示例 2：**

```
输入：nums = [9], target = 3
输出：0
```

**提示：**

- `1 <= nums.length <= 200`
- `1 <= nums[i] <= 1000`
- `nums` 中的所有元素 **互不相同**
- `1 <= target <= 1000`

```go
func combinationSum4(nums []int, target int) int {
	length := len(nums)
	if length == 0 {
		return 0
	}
	dp := make([]int, target + 1)
	dp[0] = 1
	for i := 1; i < target + 1; i++ {
		for j := 0; j < length; j++ {
			if i >= nums[j] {
				dp[i] += dp[i - nums[j]]
			}
		}
	}
	return dp[target]
}
```

#### [416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

**示例 1：**

```
输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。
```

**示例 2：**

```
输入：nums = [1,2,3,5]
输出：false
解释：数组不能分割成两个元素和相等的子集。
```

**提示：**

- `1 <= nums.length <= 200`
- `1 <= nums[i] <= 100`

```go
func canPartition(nums []int) bool {
	sum := 0
	for _, m := range nums {
		sum += m
	}
	if sum % 2 == 1{ return false }
	target := sum / 2
	dp := make([]bool, target + 1)
	dp[0] = true
	for i := 0; i < len(nums); i++ {
		for j := target; j >= nums[i]; j-- {
			dp[j] = dp[j] || dp[j - nums[i]]
		}
	}
	return dp[target]
}
```

#### [62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)

一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png)

```
输入：m = 3, n = 7
输出：28
```

**示例 2：**

```
输入：m = 3, n = 2
输出：3
解释：
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右
3. 向下 -> 向右 -> 向下
```

**示例 3：**

```
输入：m = 7, n = 3
输出：28
```

**示例 4：**

```
输入：m = 3, n = 3
输出：6
```

**提示：**

- `1 <= m, n <= 100`
- 题目数据保证答案小于等于 `2 * 109`

```go
func uniquePaths(m int, n int) int {
     dp := make([][]int, m + 1)
     for i := 0; i < m + 1; i++ {
         dp[i] = make([]int, n + 1)
     }
     dp[0][1] = 1
     for i := 1; i < m + 1; i++ {
         for j := 1; j < n + 1; j++ {
             dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
         }
     }
     return dp[m][n]
}
```

#### [63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)

一个机器人位于一个 *m x n* 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/robot_maze.png)

网格中的障碍物和空位置分别用 `1` 和 `0` 来表示。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg)

```
输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
输出：2
解释：
3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：
1. 向右 -> 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右 -> 向右
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/11/04/robot2.jpg)

```
输入：obstacleGrid = [[0,1],[0,0]]
输出：1
```

**提示：**

- `m == obstacleGrid.length`
- `n == obstacleGrid[i].length`
- `1 <= m, n <= 100`
- `obstacleGrid[i][j]` 为 `0` 或 `1`

```go
func uniquePathsWithObstacles(obstacleGrid [][]int) int {
    m, n := len(obstacleGrid), len(obstacleGrid[0])
    dp := make([][]int, m + 1)
    for i := 0; i < m + 1; i++ {
        dp[i] = make([]int, n + 1)
    }
    dp[0][1] = 1
    for i := 1; i < m + 1; i++ {
        for j := 1; j < n + 1; j++ {
            if obstacleGrid[i - 1][j - 1] == 1 {
                dp[i][j] = 0
            } else {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
            }
            
        }
    }
    return dp[m][n]
}
```

#### [96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)

给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg)

```
输入：n = 3
输出：5
```

**示例 2：**

```
输入：n = 1
输出：1
```

**提示：**

- `1 <= n <= 19`

```go
func numTrees(n int) int {
	dp := make([]int, n + 1)
	dp[0] = 1
	dp[1] = 1
	for i := 2; i < n + 1; i++ {
		for j := 0; j < i; j++ {
			dp[i] += dp[j] * dp[i - j - 1]
		}
	}
	return dp[n]
}
```

#### [95. 不同的二叉搜索树 II](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)

给你一个整数 `n` ，请你生成并返回所有由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的不同 **二叉搜索树** 。可以按 **任意顺序** 返回答案。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg)

```
输入：n = 3
输出：[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]
```

**示例 2：**

```
输入：n = 1
输出：[[1]]
```

**提示**

- `1 <= n <= 8`

```

```

#### [887. 鸡蛋掉落](https://leetcode-cn.com/problems/super-egg-drop/)

给你 `k` 枚相同的鸡蛋，并可以使用一栋从第 `1` 层到第 `n` 层共有 `n` 层楼的建筑。

已知存在楼层 `f` ，满足 `0 <= f <= n` ，任何从 **高于** `f` 的楼层落下的鸡蛋都会碎，从 `f` 楼层或比它低的楼层落下的鸡蛋都不会破。

每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 `x` 扔下（满足 `1 <= x <= n`）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 **重复使用** 这枚鸡蛋。

请你计算并返回要确定 `f` **确切的值** 的 **最小操作次数** 是多少？

**示例 1：**

```
输入：k = 1, n = 2
输出：2
解释：
鸡蛋从 1 楼掉落。如果它碎了，肯定能得出 f = 0 。 
否则，鸡蛋从 2 楼掉落。如果它碎了，肯定能得出 f = 1 。 
如果它没碎，那么肯定能得出 f = 2 。 
因此，在最坏的情况下我们需要移动 2 次以确定 f 是多少。 
```

**示例 2：**

```
输入：k = 2, n = 6
输出：3
```

**示例 3：**

```
输入：k = 3, n = 14
输出：4
```

**提示：**

- `1 <= k <= 100`
- `1 <= n <= 104`

```

```