# 一、数组

#### [283. 移动零](https://leetcode-cn.com/problems/move-zeroes/)

难度简单994收藏分享切换为英文接收动态反馈

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**示例:**

```
输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
```

**说明**:

1. 必须在原数组上操作，不能拷贝额外的数组。
2. 尽量减少操作次数。

```go
func moveZeroes(nums []int)  {
	l, r := 0, 1
	for ; r < len(nums); r++ {
        // 左是0，右不是0时交换
		if nums[l] == 0 && nums[r] != 0 {
			nums[l], nums[r] = nums[r], nums[l]
		}
        // 左不是0时，l+1
        if nums[l] != 0 {
			l++
		}
	}
}
```



#### [88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)

难度简单802收藏分享切换为英文接收动态反馈

给你两个有序整数数组 `nums1` 和 `nums2`，请你将 `nums2` 合并到 `nums1` 中*，*使 `nums1` 成为一个有序数组。

初始化 `nums1` 和 `nums2` 的元素数量分别为 `m` 和 `n` 。你可以假设 `nums1` 的空间大小等于 `m + n`，这样它就有足够的空间保存来自 `nums2` 的元素。

**示例 1：**

```
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
```

**示例 2：**

```
输入：nums1 = [1], m = 1, nums2 = [], n = 0
输出：[1]
```

**提示：**

- `nums1.length == m + n`
- `nums2.length == n`
- `0 <= m, n <= 200`
- `1 <= m + n <= 200`
- `-109 <= nums1[i], nums2[i] <= 109`

```go
func merge(nums1 []int, m int, nums2 []int, n int) {
	for p := m + n; m > 0 && n > 0; p-- {
		if nums2[n-1] >= nums1[m-1] {
			nums1[p-1] = nums2[n-1]
			n--
		} else {
			nums1[p-1] = nums1[m-1]
			m--
		}
	}
	for ; n-1 >= 0; n-- {
		nums1[n-1] = nums2[n-1]
	}
}
```



#### [66. 加一](https://leetcode-cn.com/problems/plus-one/)

难度简单645收藏分享切换为英文接收动态反馈

给定一个由 **整数** 组成的 **非空** 数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储**单个**数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。

**示例 1：**

```
输入：digits = [1,2,3]
输出：[1,2,4]
解释：输入数组表示数字 123。
```

**示例 2：**

```
输入：digits = [4,3,2,1]
输出：[4,3,2,2]
解释：输入数组表示数字 4321。
```

**示例 3：**

```
输入：digits = [0]
输出：[1]
```

**提示：**

- `1 <= digits.length <= 100`
- `0 <= digits[i] <= 9`

```go
func plusOne(digits []int) []int {
	for i:=len(digits)-1; i>=0; i-- {
		if digits[i] < 9 {  // 当前位置不用进位，+1，然后直接返回
			digits[i]++
			return digits
		} else {            // 要进位，当前位置置0
			digits[i] = 0
		}
	}
	return append([]int{1}, digits...)
}
```



#### [26. 删除有序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

难度简单1888收藏分享切换为英文接收动态反馈

给你一个有序数组 `nums` ，请你**[ 原地](http://baike.baidu.com/item/原地算法)** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 **[原地 ](https://baike.baidu.com/item/原地算法)修改输入数组** 并在使用 O(1) 额外空间的条件下完成。

 

**说明:**

为什么返回数值是整数，但输出的答案是数组呢?

请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:

```
// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
```

**示例 1：**

```
输入：nums = [1,1,2]
输出：2, nums = [1,2]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
```

**示例 2：**

```
输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4]
解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。
```

**提示：**

- `0 <= nums.length <= 3 * 104`
- `-104 <= nums[i] <= 104`
- `nums` 已按升序排列

```go
// 双指针，只用管前面不重复的元素，后面的那些不用管。
func removeDuplicates(nums []int) int {
	if len(nums) < 2 { return len(nums) }
	l, r := 0, 1
	for ; r < len(nums); r++ {
		if nums[l] != nums[r] {
			l++
			nums[l] = nums[r]
		}
	}
	return l+1
}
```



#### [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

难度简单1540收藏分享切换为英文接收动态反馈

假设你正在爬楼梯。需要 *n* 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**注意：**给定 *n* 是一个正整数。

**示例 1：**

```
输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
```

**示例 2：**

```
输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶
```

```go
func climbStairs(n int) int {
	if n <= 3 { return n }
	first, second := 1, 2
	res := 0
	for i := 3; i <= n; i++{
		res = first + second
		first, second = second, res
	}
	return res
}
```



#### [11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)

难度中等2274收藏分享切换为英文接收动态反馈

给你 `n` 个非负整数 `a1，a2，...，a``n`，每个数代表坐标中的一个点 `(i, ai)` 。在坐标内画 `n` 条垂直线，垂直线 `i` 的两个端点分别为 `(i, ai)` 和 `(i, 0)` 。找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。

**说明：**你不能倾斜容器。

**示例 1：**

![img](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg)

```
输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
```

**示例 2：**

```
输入：height = [1,1]
输出：1
```

**示例 3：**

```
输入：height = [4,3,2,1,4]
输出：16
```

**示例 4：**

```
输入：height = [1,2,1]
输出：2
```

**提示：**

- `n = height.length`
- `2 <= n <= 3 * 104`
- `0 <= height[i] <= 3 * 104`

```go
// 双指针
func maxArea(height []int) int {
	l, r, res := 0, len(height) - 1, 0
	for l < r {
		res = max(res, min(height[l], height[r]) * (r - l))
		// 判断条件是哪边矮，移哪边
		if height[l] < height[r] {
			l++
		} else {
			r--
		}
	}
	return res
}

func max(a, b int) int {
	if a>b {return a}
	return b
}

func min(a, b int) int {
	if a<b {return a}
	return b
}
```



#### [15. 三数之和](https://leetcode-cn.com/problems/3sum/)

难度中等3095收藏分享切换为英文接收动态反馈

给你一个包含 `n` 个整数的数组 `nums`，判断 `nums` 中是否存在三个元素 *a，b，c ，*使得 *a + b + c =* 0 ？请你找出所有和为 `0` 且不重复的三元组。

**注意：**答案中不可以包含重复的三元组。

**示例 1：**

```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
```

**示例 2：**

```
输入：nums = []
输出：[]
```

**示例 3：**

```
输入：nums = [0]
输出：[]
```

**提示：**

- `0 <= nums.length <= 3000`
- `-105 <= nums[i] <= 105`

```go
func threeSum(nums []int) [][]int {
	sort.Ints(nums)
	var res [][]int
	for i := 0; i < len(nums) - 2; i++ {
		// 去重，需要第一个数不重复
		if i > 0 && nums[i] == nums[i - 1] {
			continue
		}
		l, r := i + 1, len(nums) - 1
		for l < r {
			// 去重，也需要第一个数不重复
			if l > i + 1 && nums[l] == nums[l - 1] {
				l++
				continue
			}
			if nums[i] + nums[l] + nums[r] < 0 {
				l++
			} else if nums[i] + nums[l] + nums[r] > 0 {
				r--
			} else {
				res = append(res, []int{nums[i], nums[l], nums[r]})
				l++
				r--
			}
		}
	}
	return res
}
```



#### [189. 旋转数组](https://leetcode-cn.com/problems/rotate-array/)

难度中等921收藏分享切换为英文接收动态反馈

给定一个数组，将数组中的元素向右移动 `k` 个位置，其中 `k` 是非负数。

**进阶：**

- 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。
- 你可以使用空间复杂度为 O(1) 的 **原地** 算法解决这个问题吗？

**示例 1:**

```
输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4]
```

**示例 2:**

```
输入：nums = [-1,-100,3,99], k = 2
输出：[3,99,-1,-100]
解释: 
向右旋转 1 步: [99,-1,-100,3]
向右旋转 2 步: [3,99,-1,-100]
```

**提示：**

- `1 <= nums.length <= 2 * 104`
- `-231 <= nums[i] <= 231 - 1`
- `0 <= k <= 105`

```go
// 3次换序
func rotate(nums []int, k int)  {
	l, r := 0, len(nums) - 1
	for l < r {
		nums[l], nums[r] = nums[r], nums[l]
		r--
		l++
	}
	l, r = 0, (k % len(nums)) - 1
	for l < r {
		nums[l], nums[r] = nums[r], nums[l]
		r--
		l++
	}
	l, r = k % len(nums), len(nums) - 1
	for l < r {
		nums[l], nums[r] = nums[r], nums[l]
		r--
		l++
	}
}
```



# 二、链表

#### [234. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)

难度简单956

请判断一个链表是否为回文链表。

**示例 1:**

```
输入: 1->2
输出: false
```

**示例 2:**

```
输入: 1->2->2->1
输出: true
```

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func isPalindrome(head *ListNode) bool {
    if head == nil || head.Next == nil {
        return true
    }
    slow, fast := head, head
    var pre *ListNode
    cur := head
    for fast != nil && fast.Next != nil {
        cur = slow
        slow = slow.Next
        fast = fast.Next.Next
        cur.Next = pre
        pre = cur
    }
    if fast != nil {
        slow = slow.Next
    }
    for cur != nil && slow != nil {
        if cur.Val != slow.Val {
            return false
        }
        cur = cur.Next
        slow = slow.Next
    }
    return true
}
```



#### [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

难度简单1602收藏分享切换为英文接收动态反馈

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg)

```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**示例 2：**

```
输入：l1 = [], l2 = []
输出：[]
```

**示例 3：**

```
输入：l1 = [], l2 = [0]
输出：[0]
```

**提示：**

- 两个链表的节点数目范围是 `[0, 50]`
- `-100 <= Node.val <= 100`
- `l1` 和 `l2` 均按 **非递减顺序** 排列

```go
// 新建node
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
	prehead := &ListNode{}
	result := prehead
	for l1 != nil && l2 != nil {
		if l1.Val < l2.Val {
			prehead.Next = l1
			l1 = l1.Next
		}else{
			prehead.Next = l2
			l2 = l2.Next
		}
		prehead = prehead.Next
	}
	if l1 != nil {
		prehead.Next = l1
	}
	if l2 != nil {
		prehead.Next = l2
	}
	return result.Next
}
```

#### [23. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

难度困难1368

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

 

**示例 1：**

```
输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6
```

**示例 2：**

```
输入：lists = []
输出：[]
```

**示例 3：**

```
输入：lists = [[]]
输出：[]
```

 

**提示：**

- `k == lists.length`
- `0 <= k <= 10^4`
- `0 <= lists[i].length <= 500`
- `-10^4 <= lists[i][j] <= 10^4`
- `lists[i]` 按 **升序** 排列
- `lists[i].length` 的总和不超过 `10^4`

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func mergeKLists(lists []*ListNode) *ListNode {
    if len(lists) == 0 { return nil }
    ans := merge(lists, 0, len(lists) - 1)
    return ans[0]
}

func merge(lists []*ListNode, l, r int) []*ListNode {
    if len(lists) == 1 { return lists }
    ans := []*ListNode{}
    for l < r {
        ans = append(ans, mergeTwoLists(lists[l], lists[r]))
        l++
        r--
    }
    if l == r {
        ans = append(ans, lists[l])
    }
    return merge(ans, 0, len(ans) - 1)
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    head := &ListNode{
        Val: 0,
    }
    newNode := head
    l1Node, l2Node := l1, l2
    for l1Node != nil && l2Node != nil {
        if l1Node.Val < l2Node.Val {
            newNode.Next = l1Node
            l1Node = l1Node.Next
        } else {
            newNode.Next = l2Node
            l2Node = l2Node.Next
        }
        newNode = newNode.Next
    }
    for l1Node != nil {
        newNode.Next = l1Node
        l1Node = l1Node.Next
        newNode = newNode.Next
    }
    for l2Node != nil {
        newNode.Next = l2Node
        l2Node = l2Node.Next
        newNode = newNode.Next
    }
    return head.Next
}
```



#### [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

难度简单1583收藏分享切换为英文接收动态反馈

反转一个单链表。

**示例:**

```
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
```

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func reverseList(head *ListNode) *ListNode {
    if head == nil || head.Next == nil { return head }
    cur := head
    var pre *ListNode
    for cur != nil {
        nxt := cur.Next
        cur.Next = pre
        pre = cur
        cur = nxt
    }
    return pre
}
```



#### [92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)

难度中等878

给你单链表的头指针 `head` 和两个整数 `left` 和 `right` ，其中 `left <= right` 。请你反转从位置 `left` 到位置 `right` 的链表节点，返回 **反转后的链表** 。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg)

```
输入：head = [1,2,3,4,5], left = 2, right = 4
输出：[1,4,3,2,5]
```

**示例 2：**

```
输入：head = [5], left = 1, right = 1
输出：[5]
```

**提示：**

- 链表中节点数目为 `n`
- `1 <= n <= 500`
- `-500 <= Node.val <= 500`
- `1 <= left <= right <= n`

```go
func reverseBetween(head *ListNode, left int, right int) *ListNode {
    root := &ListNode{
        Next: head,
    }
    node := root
    i := 0
    for ; i < left - 1; i++ {
        node = node.Next
    }
    leftNode := node
    for ; i < right; i++ {
        node = node.Next
    }
    rightNode := node.Next
    node.Next = nil
    tempNode := leftNode.Next
    leftNode.Next = nil
    leftNode.Next = reverse(tempNode)
    tempNode.Next = rightNode
    return root.Next
}

func reverse(head *ListNode) *ListNode {
    var pre *ListNode
    cur := head
    for cur != nil {
        temp := cur.Next
        cur.Next = pre
        pre = cur
        cur = temp
    }
    return pre
}
```



#### [25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)

难度困难1063

给你一个链表，每 *k* 个节点一组进行翻转，请你返回翻转后的链表。

*k* 是一个正整数，它的值小于或等于链表的长度。

如果节点总数不是 *k* 的整数倍，那么请将最后剩余的节点保持原有顺序。

**进阶：**

- 你可以设计一个只使用常数额外空间的算法来解决此问题吗？
- **你不能只是单纯的改变节点内部的值**，而是需要实际进行节点交换。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg)

```
输入：head = [1,2,3,4,5], k = 2
输出：[2,1,4,3,5]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg)

```
输入：head = [1,2,3,4,5], k = 3
输出：[3,2,1,4,5]
```

**示例 3：**

```
输入：head = [1,2,3,4,5], k = 1
输出：[1,2,3,4,5]
```

**示例 4：**

```
输入：head = [1], k = 1
输出：[1]
```

**提示：**

- 列表中节点的数量在范围 `sz` 内
- `1 <= sz <= 5000`
- `0 <= Node.val <= 1000`
- `1 <= k <= sz`

```go
func reverseKGroup(head *ListNode, k int) *ListNode {
    if head == nil { return head }

    root := &ListNode{
        Next: head,
    }
    pre, cur := root, head
    for cur != nil {
        tal := pre
        for i := 0; i < k; i++ {
            if tal.Next == nil {
                return root.Next
            }
            tal = tal.Next
        }
        nxt := tal.Next

        cur, tal = reverse(cur, tal)
        tal.Next = nxt
        pre.Next = cur
        pre = tal
        cur = nxt
    }
    return root.Next
}

func reverse(cur, tal *ListNode) (*ListNode, *ListNode) {
    var pre *ListNode
    c, t := cur, tal
    for pre != t {
        nxt := c.Next
        c.Next = pre
        pre = c
        c = nxt
    }
    return tal, cur
}
```



#### [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

难度中等858收藏分享切换为英文接收动态反馈

给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。

**你不能只是单纯的改变节点内部的值**，而是需要实际的进行节点交换。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg)

```
输入：head = [1,2,3,4]
输出：[2,1,4,3]
```

**示例 2：**

```
输入：head = []
输出：[]
```

**示例 3：**

```
输入：head = [1]
输出：[1]
```

**提示：**

- 链表中节点的数目在范围 `[0, 100]` 内
- `0 <= Node.val <= 100`

```go
func swapPairs(head *ListNode) *ListNode {
	res := &ListNode{0, head}
	prev, curr := res, head
	for curr != nil && curr.Next != nil {
		next := curr.Next
		// 互换位置过程
		prev.Next = next
		curr.Next = next.Next
		next.Next = curr
		// 换位置过程
		prev, curr = curr, curr.Next
	}
	return res.Next
}
```



#### [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

难度简单982收藏分享切换为英文接收动态反馈

给定一个链表，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。

如果链表中存在环，则返回 `true` 。 否则，返回 `false` 。

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png)

```
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```

**示例 2：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png)

```
输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。
```

**示例 3：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png)

```
输入：head = [1], pos = -1
输出：false
解释：链表中没有环。
```

**提示：**

- 链表中节点的数目范围是 `[0, 104]`
- `-105 <= Node.val <= 105`
- `pos` 为 `-1` 或者链表中的一个 **有效索引** 。

```go
// 快慢指针
func hasCycle(head *ListNode) bool {
	s, f := head, head
	for s != nil && f != nil && f.Next != nil {
		s = s.Next
		f = f.Next.Next
		if f == s { return true }
	}
	return false
}
```



#### [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

难度中等909收藏分享切换为英文接收动态反馈

给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 `null`。

为了表示给定链表中的环，我们使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 `pos` 是 `-1`，则在该链表中没有环。**注意，`pos` 仅仅是用于标识环的情况，并不会作为参数传递到函数中。**

**说明：**不允许修改给定的链表。

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png)

```
输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。
```

**示例 2：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png)

```
输入：head = [1,2], pos = 0
输出：返回索引为 0 的链表节点
解释：链表中有一个环，其尾部连接到第一个节点。
```

**示例 3：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png)

```
输入：head = [1], pos = -1
输出：返回 null
解释：链表中没有环。
```

**提示：**

- 链表中节点的数目范围在范围 `[0, 104]` 内
- `-105 <= Node.val <= 105`
- `pos` 的值为 `-1` 或者链表中的一个有效索引

```go
func detectCycle(head *ListNode) *ListNode {
	s, f := head, head
	for s != nil && f != nil && f.Next != nil {
		s = s.Next
		f = f.Next.Next
		// 当判断为环时，需要做的就是画个图，s距交点的举例=head到交点的举例
		if f == s {
			f = head
			for f != s {
				s, f = s.Next, f.Next
			}
			return f
		}
	}
	return nil
}
```



# 三、栈和队列

#### [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

难度简单2244收藏分享切换为英文接收动态反馈

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。

**示例 1：**

```
输入：s = "()"
输出：true
```

**示例 2：**

```
输入：s = "()[]{}"
输出：true
```

**示例 3：**

```
输入：s = "(]"
输出：false
```

**示例 4：**

```
输入：s = "([)]"
输出：false
```

**示例 5：**

```
输入：s = "{[]}"
输出：true
```

**提示：**

- `1 <= s.length <= 104`
- `s` 仅由括号 `'()[]{}'` 组成

```go
func isValid(s string) bool {
	l := []byte(s)
	stack := []byte{}
	for _, b := range l {
		if b == '(' || b == '[' || b == '{' {
			stack = append(stack, b)
		} else if b == ')' {
			if len(stack) == 0 || stack[len(stack) - 1] != '(' { return false }
			stack = stack[:len(stack) - 1]
		} else if b == ']' {
			if len(stack) == 0 || stack[len(stack) - 1] != '[' { return false }
			stack = stack[:len(stack) - 1]
        } else if b == '}' {
			if len(stack) == 0 || stack[len(stack) - 1] != '{' { return false }
			stack = stack[:len(stack) - 1]
		}
	}
	return len(stack) == 0
}
```



#### [155. 最小栈](https://leetcode-cn.com/problems/min-stack/)

难度简单839收藏分享切换为英文接收动态反馈

设计一个支持 `push` ，`pop` ，`top` 操作，并能在常数时间内检索到最小元素的栈。

- `push(x)` —— 将元素 x 推入栈中。
- `pop()` —— 删除栈顶的元素。
- `top()` —— 获取栈顶元素。
- `getMin()` —— 检索栈中的最小元素。

**示例:**

```
输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

输出：
[null,null,null,null,-3,null,0,-2]

解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
```

**提示：**

- `pop`、`top` 和 `getMin` 操作总是在 **非空栈** 上调用。

```go
type MinStack struct {
    stack  []int
    minStk []int
}

/** initialize your data structure here. */
func Constructor() MinStack {
    return MinStack{
        stack:  []int{},
        minStk: []int{},
    }
}

// Push 入栈，如果插入值，当前插入值小于栈顶元素，则入栈，栈顶元素保存的则为当前栈的最小元素
func (m *MinStack) Push(x int)  {
    m.stack = append(m.stack, x)
    if len(m.minStk) == 0 || m.minStk[len(m.minStk) - 1] >= x {
        m.minStk = append(m.minStk, x)
    } else {
        m.minStk = append(m.minStk, m.minStk[len(m.minStk) - 1])
    }
}

// Pop 出栈，如果stack出栈等于minStk栈顶元素，则说明此时栈内的最小元素改变了。
func (m *MinStack) Pop()  {
    m.stack = m.stack[: len(m.stack) - 1]
    m.minStk = m.minStk[: len(m.minStk) - 1]
}

// Top stack的栈顶元素
func (m *MinStack) Top() int {
    return  m.stack[len(m.stack) - 1]
}

// GetMin minStk的栈顶元素
func (m *MinStack) GetMin() int {
    return  m.minStk[len(m.minStk) - 1]
}


/**
 * Your MinStack object will be instantiated and called as such:
 * obj := Constructor();
 * obj.Push(x);
 * obj.Pop();
 * param_3 := obj.Top();
 * param_4 := obj.GetMin();
 */
```



#### [641. 设计循环双端队列](https://leetcode-cn.com/problems/design-circular-deque/)

难度中等76收藏分享切换为英文接收动态反馈

设计实现双端队列。
你的实现需要支持以下操作：

- MyCircularDeque(k)：构造函数,双端队列的大小为k。
- insertFront()：将一个元素添加到双端队列头部。 如果操作成功返回 true。
- insertLast()：将一个元素添加到双端队列尾部。如果操作成功返回 true。
- deleteFront()：从双端队列头部删除一个元素。 如果操作成功返回 true。
- deleteLast()：从双端队列尾部删除一个元素。如果操作成功返回 true。
- getFront()：从双端队列头部获得一个元素。如果双端队列为空，返回 -1。
- getRear()：获得双端队列的最后一个元素。 如果双端队列为空，返回 -1。
- isEmpty()：检查双端队列是否为空。
- isFull()：检查双端队列是否满了。

**示例：**

```
MyCircularDeque circularDeque = new MycircularDeque(3); // 设置容量大小为3
circularDeque.insertLast(1);			        		// 返回 true
circularDeque.insertLast(2);			        		// 返回 true
circularDeque.insertFront(3);			        		// 返回 true
circularDeque.insertFront(4);			        		// 已经满了，返回 false
circularDeque.getRear();  								// 返回 2
circularDeque.isFull();				        			// 返回 true
circularDeque.deleteLast();			        			// 返回 true
circularDeque.insertFront(4);			        		// 返回 true
circularDeque.getFront();								// 返回 4
 
```

**提示：**

- 所有值的范围为 [1, 1000]
- 操作次数的范围为 [1, 1000]
- 请不要使用内置的双端队列库。

```go
type MyCircularDeque struct {
	queue []int
	first int
	rear  int
	size  int
}

/** Initialize your data structure here. Set the size of the deque to be k. */
func Constructor(k int) MyCircularDeque {
	return MyCircularDeque{
		queue: make([]int, k, k),
		first: 0,
		rear:  1,
		size:  0,
	}
}

// 添加时，先添加，再移位
/** Adds an item at the front of Deque. Return true if the operation is successful. */
func (this *MyCircularDeque) InsertFront(value int) bool {
	if this.IsFull() { return false }
	this.queue[this.first] = value
	this.size++
	this.first = (len(this.queue) + this.first-1) % (len(this.queue))
	return true
}

/** Adds an item at the rear of Deque. Return true if the operation is successful. */
func (this *MyCircularDeque) InsertLast(value int) bool {
	if this.IsFull() { return false }
	this.queue[this.rear] = value
	this.size++
	this.rear = (this.rear+1) % (len(this.queue))
	return true
}

// 删除时，先移动索引，再删除
/** Deletes an item from the front of Deque. Return true if the operation is successful. */
func (this *MyCircularDeque) DeleteFront() bool {
	if this.IsEmpty() { return false }
	this.first = (this.first+1) % (len(this.queue))
	this.queue[this.first] = 0
	this.size--
	return true
}

/** Deletes an item from the rear of Deque. Return true if the operation is successful. */
func (this *MyCircularDeque) DeleteLast() bool {
	if this.IsEmpty() { return false }
	this.rear = (len(this.queue)+this.rear-1) % (len(this.queue))
	this.queue[this.rear] = 0
	this.size--
	return true
}

/** Get the front item from the deque. */
func (this *MyCircularDeque) GetFront() int {
	if this.IsEmpty() { return -1 }
	return this.queue[(this.first+1) % (len(this.queue))]
}

/** Get the last item from the deque. */
func (this *MyCircularDeque) GetRear() int {
	if this.IsEmpty() { return -1 }
	return this.queue[(len(this.queue)+this.rear-1) % (len(this.queue))]
}

/** Checks whether the circular deque is empty or not. */
func (this *MyCircularDeque) IsEmpty() bool {
	return this.size == 0
}

/** Checks whether the circular deque is full or not. */
func (this *MyCircularDeque) IsFull() bool {
	return this.size == len(this.queue)

```



#### [84. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)

难度困难1244收藏分享切换为英文接收动态反馈

给定 *n* 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram.png)

以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 `[2,1,5,6,2,3]`。

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram_area.png)

图中阴影部分为所能勾勒出的最大矩形面积，其面积为 `10` 个单位。

**示例:**

```
输入: [2,1,5,6,2,3]
输出: 10
```

```go
// 单调栈，维护一个单调增的栈，用来存放右边界之前的所有值
func largestRectangleArea(heights []int) int {
    ary := []int{0}
    ary = append(ary, heights...)
    ary = append(ary, 0)
    // 存索引
    stk := []int{}
    ans := 0
    for i := 0; i < len(ary); i++ {
        for len(stk) != 0 && ary[i] < ary[stk[len(stk) - 1]] {
            idx := stk[len(stk) - 2]
            // 因为是单调增的栈，idx和i之间都是更高的柱子。所以长度要i-idx-1
            ans = max(ans, ary[stk[len(stk) - 1]] * (i - idx - 1))
            stk = stk[:len(stk) - 1]
        }
        stk = append(stk, i)
    }
    return ans
}

func max(x, y int) int {
    if x > y {
        return x
    }
    return y
}

```



#### [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)

难度困难2153收藏分享切换为英文接收动态反馈

给定 *n* 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png)

```
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 
```

**示例 2：**

```
输入：height = [4,2,0,3,2,5]
输出：9
```

**提示：**

- `n == height.length`
- `0 <= n <= 3 * 104`
- `0 <= height[i] <= 105`

```go
func trap(height []int) int {
    stack := []int{}
    water := 0
    // 最左边部分不会接雨水，左边持续升高时，stack都会弹出所有元素。
    for i := 0; i< len(height); i++ {
        for len(stack) != 0 && height[i] > height[stack[len(stack) - 1]] {
            popnum := stack[len(stack) - 1]
            // 出现相同高度的情况（其实也可以不用处理，如果不处理，相同高度时后面的hig为0，会产生很多无效的计算）
            for len(stack) != 0 && height[popnum] == height[stack[len(stack) - 1]] {
                stack = stack[:len(stack) - 1]
            }
            if len(stack) == 0 { break }
            le, ri := stack[len(stack) - 1], i
            hig := min(height[ri], height[le]) - height[popnum]
            wid := ri - le - 1
            water += wid * hig
        }
        stack = append(stack, i)
    }
    return water
}

func min(a, b int) int {
    if a < b { return a }
    return b
}
```



#### [239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)

难度困难896收藏分享切换为英文接收动态反馈

给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。

返回滑动窗口中的最大值。

**示例 1：**

```
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

**示例 2：**

```
输入：nums = [1], k = 1
输出：[1]
```

**示例 3：**

```
输入：nums = [1,-1], k = 1
输出：[1,-1]
```

**示例 4：**

```
输入：nums = [9,11], k = 2
输出：[11]
```

**示例 5：**

```
输入：nums = [4,-2], k = 2
输出：[4]
```

**提示：**

- `1 <= nums.length <= 105`
- `-104 <= nums[i] <= 104`
- `1 <= k <= nums.length`

```go
// 维护一个单调减的双端队列，这个队列存可能是最大值的数组下标，这个队列的第一个元素就是最大值下标。
func maxSlidingWindow(nums []int, k int) []int {
	queue := []int{}
	for i:=0; i<k; i++ {
		for len(queue)!=0 && nums[i] >= nums[queue[len(queue)-1]] {
			queue = queue[:len(queue)-1]
		}
		queue = append(queue, i)
	}
	res := []int{nums[queue[0]]}
	for i:=k; i<len(nums); i++ {
		for len(queue)!=0 && nums[i] >= nums[queue[len(queue)-1]] {
			queue = queue[:len(queue)-1]
		}
		queue = append(queue, i)
		// 在这里判断队列第一个元素是否还在窗口里
		for queue[0]+k <= i {
			queue = queue[1:]
		}
		res = append(res, nums[queue[0]])
	}
	return res
}
```



#### [739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)

难度中等797

请根据每日 `气温` 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。

例如，给定一个列表 `temperatures = [73, 74, 75, 71, 69, 72, 76, 73]`，你的输出应该是 `[1, 1, 4, 2, 1, 1, 0, 0]`。

**提示：**`气温` 列表长度的范围是 `[1, 30000]`。每个气温的值的均为华氏度，都是在 `[30, 100]` 范围内的整数。

```go
func dailyTemperatures(temperatures []int) []int {
    stack := []int{0}
    ans := make([]int, len(temperatures))
    for i := 1; i < len(temperatures); i++ {
        for len(stack) != 0 && temperatures[i] > temperatures[stack[len(stack) - 1]] {
            idx := stack[len(stack) - 1]
            ans[idx] = i - idx
            stack = stack[:len(stack) - 1]
        }
        stack = append(stack, i)
    }
    return ans

}
```



#### [496. 下一个更大元素 I](https://leetcode-cn.com/problems/next-greater-element-i/)

难度简单442

给你两个 **没有重复元素** 的数组 `nums1` 和 `nums2` ，其中`nums1` 是 `nums2` 的子集。

请你找出 `nums1` 中每个元素在 `nums2` 中的下一个比其大的值。

`nums1` 中数字 `x` 的下一个更大元素是指 `x` 在 `nums2` 中对应位置的右边的第一个比 `x` 大的元素。如果不存在，对应位置输出 `-1` 。

 

**示例 1:**

```
输入: nums1 = [4,1,2], nums2 = [1,3,4,2].
输出: [-1,3,-1]
解释:
    对于 num1 中的数字 4 ，你无法在第二个数组中找到下一个更大的数字，因此输出 -1 。
    对于 num1 中的数字 1 ，第二个数组中数字1右边的下一个较大数字是 3 。
    对于 num1 中的数字 2 ，第二个数组中没有下一个更大的数字，因此输出 -1 。
```

**示例 2:**

```
输入: nums1 = [2,4], nums2 = [1,2,3,4].
输出: [3,-1]
解释:
    对于 num1 中的数字 2 ，第二个数组中的下一个较大数字是 3 。
    对于 num1 中的数字 4 ，第二个数组中没有下一个更大的数字，因此输出 -1 。
```

**提示：**

- `1 <= nums1.length <= nums2.length <= 1000`
- `0 <= nums1[i], nums2[i] <= 104`
- `nums1`和`nums2`中所有整数 **互不相同**
- `nums1` 中的所有整数同样出现在 `nums2` 中

```go
func nextGreaterElement(nums1 []int, nums2 []int) []int {
    stack := []int{}
    temp := map[int]int{}
    for i := 0; i < len(nums2); i++ {
        for len(stack) != 0 && nums2[i] > nums2[stack[len(stack) - 1]] {
            temp[nums2[stack[len(stack) - 1]]] = nums2[i]
            stack = stack[:len(stack) - 1]
        }
        stack = append(stack, i)
    }
    ans := []int{}
    for _, n := range nums1  {
        v, ok := temp[n]; 
        if !ok {
            ans = append(ans, -1)
            continue
        }
        ans = append(ans, v)
        
    }
    return ans
}
```



#### [503. 下一个更大元素 II](https://leetcode-cn.com/problems/next-greater-element-ii/)

难度中等446

给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。

**示例 1:**

```
输入: [1,2,1]
输出: [2,-1,2]
解释: 第一个 1 的下一个更大的数是 2；
数字 2 找不到下一个更大的数； 
第二个 1 的下一个最大的数需要循环搜索，结果也是 2。
```

**注意:** 输入数组的长度不会超过 10000。

```go
func nextGreaterElements(nums []int) []int {
    n := len(nums)
    ans := make([]int, n)
    for i := 0; i < n; i++ {
        ans[i] = -1
    }
    stack := []int{}
    for i := 0; i < 2 * n; i++ {
        for len(stack) != 0 && nums[i % n] > nums[stack[len(stack) - 1]] {
            cur := stack[len(stack) - 1]
            stack = stack[:len(stack) - 1]
            ans[cur] = nums[i % n]
        }
        stack = append(stack, i % n)
    }
    return ans
}
```



#### [85. 最大矩形](https://leetcode-cn.com/problems/maximal-rectangle/)

难度困难959

给定一个仅包含 `0` 和 `1` 、大小为 `rows x cols` 的二维二进制矩阵，找出只包含 `1` 的最大矩形，并返回其面积。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg)

```
输入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
输出：6
解释：最大矩形如上图所示。
```

**示例 2：**

```
输入：matrix = []
输出：0
```

**示例 3：**

```
输入：matrix = [["0"]]
输出：0
```

**示例 4：**

```
输入：matrix = [["1"]]
输出：1
```

**示例 5：**

```
输入：matrix = [["0","0"]]
输出：0
```

**提示：**

- `rows == matrix.length`
- `cols == matrix[0].length`
- `0 <= row, cols <= 200`
- `matrix[i][j]` 为 `'0'` 或 `'1'`

```go
// 复用最大矩形，每一行及其上面的所有行整合在一起可以看最大矩形的那个问题。
func maximalRectangle(matrix [][]byte) int {
    ans := 0
    if len(matrix) == 0 {
        return ans
    }
    m, n := len(matrix), len(matrix[0])
    heights := make([]int, n)
    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            if matrix[i][j] == '1' {
                heights[j] += 1
            } else {
                heights[j] = 0
            }
        }
        ans = max(ans, largestRectangleArea(heights))
    }
    return ans
}

func largestRectangleArea(heights []int) int {
    ary := []int{0}
    ary = append(ary, heights...)
    ary = append(ary, 0)
    // 存索引
    stk := []int{}
    ans := 0
    for i := 0; i < len(ary); i++ {
        for len(stk) != 0 && ary[i] < ary[stk[len(stk) - 1]] {
            idx := stk[len(stk) - 2]
            // 因为是单调增的栈，idx和i之间都是更高的柱子。所以长度要i-idx-1
            ans = max(ans, ary[stk[len(stk) - 1]] * (i - idx - 1))
            stk = stk[:len(stk) - 1]
        }
        stk = append(stk, i)
    }
    return ans
}

func max(x, y int) int {
    if x > y {
        return x
    }
    return y
}
```



#### [224. 基本计算器](https://leetcode-cn.com/problems/basic-calculator/)

难度困难608

给你一个字符串表达式 `s` ，请你实现一个基本计算器来计算并返回它的值。

**示例 1：**

```
输入：s = "1 + 1"
输出：2
```

**示例 2：**

```
输入：s = " 2-1 + 2 "
输出：3
```

**示例 3：**

```
输入：s = "(1+(4+5+2)-3)+(6+8)"
输出：23
```

**提示：**

- `1 <= s.length <= 3 * 105`
- `s` 由数字、`'+'`、`'-'`、`'('`、`')'`、和 `' '` 组成
- `s` 表示一个有效的表达式

```go
func calculate(s string) int {
    stack := []int{}
	num, ans, sign := 0, 0, 1
	for i := 0; i < len(s); i++ {
		if s[i] == ' ' { continue }
		if s[i] <= '9' && s[i] >= '0' {
			num = num * 10 + int(s[i] - '0')
		} else if s[i] == '+' {
			ans += sign * num
			num = 0
			sign = 1
		} else if s[i] == '-' {
			ans += sign * num
			num = 0
			sign = -1
		} else if s[i] == '(' {
			stack = append(stack, ans)
			stack = append(stack, sign)
			ans = 0
			sign = 1
		} else if s[i] == ')' {
			ans += sign * num
			num = 0
			ans *= stack[len(stack) - 1]
			ans += stack[len(stack) - 2]
			stack = stack[:len(stack) - 2]
		}
	}
	if num != 0 {
		ans += sign * num
	}
	return ans
}
```



#### [227. 基本计算器 II](https://leetcode-cn.com/problems/basic-calculator-ii/)

难度中等439

给你一个字符串表达式 `s` ，请你实现一个基本计算器来计算并返回它的值。

整数除法仅保留整数部分。

**示例 1：**

```
输入：s = "3+2*2"
输出：7
```

**示例 2：**

```
输入：s = " 3/2 "
输出：1
```

**示例 3：**

```
输入：s = " 3+5 / 2 "
输出：5
```

**提示：**

- `1 <= s.length <= 3 * 105`
- `s` 由整数和算符 `('+', '-', '*', '/')` 组成，中间由一些空格隔开
- `s` 表示一个 **有效表达式**
- 表达式中的所有整数都是非负整数，且在范围 `[0, 231 - 1]` 内
- 题目数据保证答案是一个 **32-bit 整数**

```go
func calculate(s string) int {
    stack := []int{}
    preSign := '+'
    num := 0
    for i, ch := range s {
        if ch == ' ' && i != len(s) - 1 { continue }
        if ch >= '0' && ch <= '9' {
            num = num * 10 + int(ch - '0')
            if i != len(s) - 1 { continue }
        }
        switch preSign {
            case '+':
                stack = append(stack, num)
            case '-':
                stack = append(stack, -num)
            case '*':
                stack[len(stack) - 1] *= num
            default:
                stack[len(stack) - 1] /= num
        }
        preSign = ch
        num = 0
    }
    ans := 0
    for _, n := range stack {
        ans += n
    }
    return ans
}
```

