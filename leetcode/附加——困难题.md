## Hot100

#### [25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)

给你链表的头节点 `head` ，每 `k` 个节点一组进行翻转，请你返回修改后的链表。

`k` 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 `k` 的整数倍，那么请将最后剩余的节点保持原有顺序。

你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg)

```
输入：head = [1,2,3,4,5], k = 2
输出：[2,1,4,3,5]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg)

```
输入：head = [1,2,3,4,5], k = 3
输出：[3,2,1,4,5]
```

 **提示：**

- 链表中的节点数目为 `n`
- `1 <= k <= n <= 5000`
- `0 <= Node.val <= 1000`

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func reverseKGroup(head *ListNode, k int) *ListNode {
	cur := head
	var pre *ListNode
	tail := cur
	temp := cur
    // 判断剩下节点是否够k个。
	for i := 0; i < k; i++ {
		if temp == nil {
			return head
		}
		temp = temp.Next
	}
	for i := 0; i < k; i++ {
		nxt := cur.Next
		cur.Next = pre
		pre, cur = cur, nxt
	}
	// pre是当前段转序后的开头，cur是下一段的起始位置。
	tail.Next = reverseKGroup(cur, k)
	return pre
}
```

#### [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)

给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png)

```
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 
```

**示例 2：**

```
输入：height = [4,2,0,3,2,5]
输出：9
```

```go
func trap(height []int) int {
	q := []int{}
	area := 0
	for i := 0; i < len(height); i++ {
		for len(q) > 0 && height[q[len(q)-1]] < height[i] {
			b := height[q[len(q)-1]]
			q = q[:len(q)-1]
			if len(q) == 0 {
				break
			}
			l, r := q[len(q)-1], i
			h := min(height[l], height[r]) - b
			area += h * (r - l - 1)
		}
        q = append(q, i)
	}
	return area
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}
```

#### [23. 合并K个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

**示例 1：**

```
输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6
```

**示例 2：**

```
输入：lists = []
输出：[]
```

**示例 3：**

```
输入：lists = [[]]
输出：[]
```

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func mergeKLists(lists []*ListNode) *ListNode {
    size := len(lists)
    if size == 0 {
        return nil
    }
    if size == 1 {
        return lists[0]
    }
    l, r := 0, size - 1
    for l < r {
        lists[l] = merge2list(lists[l], lists[r])
        l++
        r--
    }
    return mergeKLists(lists[:r + 1])
}

func merge2list(l1, l2 *ListNode) *ListNode {
    root := &ListNode{}
    pre := root
    for l1 != nil && l2 != nil {
        if l1.Val < l2.Val {
            pre.Next = l1
            l1 = l1.Next
        } else {
            pre.Next = l2
            l2 = l2.Next
        }
        pre = pre.Next
    }
    if l1 == nil {
        pre.Next = l2
    } else {
        pre.Next = l1
    }
    
    return root.Next
}
```

#### [124. 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)

**路径** 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 **至多出现一次** 。该路径 **至少包含一个** 节点，且不一定经过根节点。

**路径和** 是路径中各节点值的总和。

给你一个二叉树的根节点 `root` ，返回其 **最大路径和** 。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg)

```
输入：root = [1,2,3]
输出：6
解释：最优路径是 2 -> 1 -> 3 ，路径和为 2 + 1 + 3 = 6
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg)

```
输入：root = [-10,9,20,null,null,15,7]
输出：42
解释：最优路径是 15 -> 20 -> 7 ，路径和为 15 + 20 + 7 = 42
```

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func maxPathSum(root *TreeNode) int {
    if root == nil {
        return 0
    }
    ans := root.Val
    helper(root, &ans)
    return ans
}

func helper(root *TreeNode, ans *int) int {
    if root == nil {
        return 0
    }
    l := helper(root.Left, ans)
    r := helper(root.Right, ans)
    *ans = max(*ans, l + r + root.Val)
    m := max(l, r) + root.Val
    return max(0, m)
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### [41. 缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/)

给你一个未排序的整数数组 `nums` ，请你找出其中没有出现的最小的正整数。

请你实现时间复杂度为 `O(n)` 并且只使用常数级别额外空间的解决方案。

**示例 1：**

```
输入：nums = [1,2,0]
输出：3
```

**示例 2：**

```
输入：nums = [3,4,-1,1]
输出：2
```

**示例 3：**

```
输入：nums = [7,8,9,11,12]
输出：1
```

```go
 // [3, 4, 1, -1]
 func firstMissingPositive(nums []int) int {
    n := len(nums)
    for i := 0; i < len(nums); i++ {
        // nums[i] != nums[nums[i]-1]是为了防止重复元素无限循环。
        for nums[i] > 0 && nums[i] <= n && nums[i] != nums[nums[i]-1] {
            // 满足在指定范围内、并且没有放在正确的位置上，才交换
            nums[nums[i]-1], nums[i] = nums[i], nums[nums[i]-1]
        }
    }
    // [1, -1, 3, 4]
    for i := 0; i < n; i++ {
        if nums[i]-1 != i {
            return i+1
        }
    }
    return n+1
}
```

#### [72. 编辑距离](https://leetcode.cn/problems/edit-distance/)

给你两个单词 `word1` 和 `word2`， *请返回将 `word1` 转换成 `word2` 所使用的最少操作数* 。

你可以对一个单词进行如下三种操作：

- 插入一个字符
- 删除一个字符
- 替换一个字符

**示例 1：**

```
输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
```

**示例 2：**

```
输入：word1 = "intention", word2 = "execution"
输出：5
解释：
intention -> inention (删除 't')
inention -> enention (将 'i' 替换为 'e')
enention -> exention (将 'n' 替换为 'x')
exention -> exection (将 'n' 替换为 'c')
exection -> execution (插入 'u')
```

```go
func minDistance(word1 string, word2 string) int {
    l1, l2 := len(word1), len(word2)
    dp := make([][]int, l1 + 1)
    for i := 0; i < l1 + 1; i++ {
        dp[i] = make([]int, l2 + 1)
        dp[i][0] = i
    }
    for i := 0; i < l2 + 1; i++ {
        dp[0][i] = i
    }
    for i := 1; i < l1 + 1; i++ {
        for j := 1; j < l2 + 1; j++ {
            if word1[i-1] == word2[j-1] {
                dp[i][j] = dp[i-1][j-1]
            } else {
                dp[i][j] = min(min(dp[i-1][j], dp[i][j-1]), dp[i-1][j-1]) + 1
            }
        }
    }
    return dp[l1][l2]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

#### [32. 最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/)

给你一个只包含 `'('` 和 `')'` 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

**示例 1：**

```
输入：s = "(()"
输出：2
解释：最长有效括号子串是 "()"
```

**示例 2：**

```
输入：s = ")()())"
输出：4
解释：最长有效括号子串是 "()()"
```

**示例 3：**

```
输入：s = ""
输出：0
```

```go
func longestValidParentheses(s string) int {
    l := len(s)
    dp := make([]int, l)
    ans := 0
    for i := 1; i < l; i++ {
        if s[i] == ')' {
            if s[i-1] == '(' {
                if i-2 < 0 {
                    dp[i] = 2
                } else {
                    dp[i] = 2 + dp[i-2]
                }
            } else if dp[i-1] > 0 {
                if i - dp[i-1] - 1 >= 0 && s[i - dp[i-1] - 1] == '(' {
                    if i - dp[i-1] - 2 < 0 {
                        dp[i] = dp[i - 1] + 2
                    } else {
                        dp[i] = dp[i - dp[i-1] - 2] + 2 + dp[i - 1]
                    }
                }
            }
        }
        ans = max(ans, dp[i])
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

**注意：**

- 对于 `t` 中重复字符，我们寻找的子字符串中该字符数量必须不少于 `t` 中该字符数量。
- 如果 `s` 中存在这样的子串，我们保证它是唯一的答案。

**示例 1：**

```
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
```

**示例 2：**

```
输入：s = "a", t = "a"
输出："a"
```

**示例 3:**

```
输入: s = "a", t = "aa"
输出: ""
解释: t 中两个字符 'a' 均应包含在 s 的子串中，
因此没有符合条件的子字符串，返回空字符串。
```

```go
func minWindow(s string, t string) string {
    ls, lt := len(s), len(t)
    if lt > ls {
        return ""
    }
    smap, tmap := map[byte]int{}, map[byte]int{}
    for i := 0; i < lt; i++ {
        tmap[t[i]]++
    }
    left := 0
    ansl, ansr := 0, 0
    length := ls + 1
    for right := 0; right < ls; right++ {
        smap[s[right]]++
        for check(smap, tmap) {
            if right - left + 1 < length {
                length = right - left + 1
                ansl, ansr = left, right
            }
            smap[s[left]]--
            left++
        }
    }
    if length == ls + 1 {
        return ""
    }
    return s[ansl: ansr + 1]
}

func check(smap, tmap map[byte]int) bool {
    for k, v := range tmap {
        if smap[k] < v {
            return false
        }
    }
    return true
}
```

#### [4. 寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/)

给定两个大小分别为 `m` 和 `n` 的正序（从小到大）数组 `nums1` 和 `nums2`。请你找出并返回这两个正序数组的 **中位数** 。

算法的时间复杂度应该为 `O(log (m+n))` 。

**示例 1：**

```
输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2
```

**示例 2：**

```
输入：nums1 = [1,2], nums2 = [3,4]
输出：2.50000
解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5
```

 方法一：变形为求第k个值。

```go
 func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
    m, n := len(nums1), len(nums2)
    if m > n {
        return findMedianSortedArrays(nums2, nums1)
    }
    // m+n为奇数，k1==k2，求第k1个值
    // 偶数，求第k1和k2的平均值
    k1, k2 := (n+m+1)/2, (n+m+2)/2
    if k1 == k2 {
        return float64(getknum(k1, nums1, nums2, 0, m-1, 0, n-1))
    }
    ans1 := getknum(k1, nums1, nums2, 0, m-1, 0, n-1)
    ans2 := getknum(k2, nums1, nums2, 0, m-1, 0, n-1)
    return float64(ans1+ans2) / 2.0
}

func getknum(k int, nums1, nums2 []int, left1, right1, left2, right2 int) int {
    l1 := right1 - left1 + 1
    l2 := right2 - left2 + 1
    // 保证nums1是短的那个。
    if l1 > l2 {
        return getknum(k, nums2, nums1, left2, right2, left1, right1)
    }
    if l1 == 0 {
        return nums2[left2+k-1]
    }
    if k == 1 {
        return min(nums1[left1], nums2[left2])
    }

    // 有可能超过短数组的长度。
    i := left1 + min(k/2, l1) - 1
    j := left2 + k/2 - 1
    if nums1[i] > nums2[j] {
        // 直接删掉j前面的值
        return getknum(k-(j-left2+1), nums1, nums2, left1, right1, j+1, right2)
    }
    // 直接删掉i前面的值
    return getknum(k-(i-left1+1), nums1, nums2, i+1, right1, left2, right2)
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

方法二：分割nums1，nums2，找到中间位置

```go
func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
    m, n := len(nums1), len(nums2)
    if m > n {
        return findMedianSortedArrays(nums2, nums1)
    }

    iMin, iMax := 0, m
    for iMin <= iMax {
        i := (iMin + iMax) / 2
        // m+n为奇数时，等式成立；偶数时应该是(m + n) / 2 - i，由于/，偶数情况下+1也行。
        j := (m + n + 1) / 2 - i 
        if i != m && nums2[j - 1] > nums1[i] {
            // nums2的前半部分大，i需要向后移动。
            iMin = i + 1
        } else if i != 0 && nums1[i - 1] > nums2[j] {
            // nums1的前半部分大，i需要向前移动。
            iMax = i - 1
        } else {
            maxLeft := 0
            if i == 0 {
                maxLeft = nums2[j - 1]
            } else if j == 0 {
                maxLeft = nums1[i - 1]
            } else {
                maxLeft = max(nums1[i - 1], nums2[j - 1])
            }
            // 奇数时，1,2前半部分的大值就是结果。
            if (m + n) % 2 == 1 {
                return float64(maxLeft)
            }
            // 偶数时，还需要求后半部分的最小值
            minRight := 0
            if i == m {
                minRight = nums2[j]
            } else if j == n {
                minRight = nums1[i]
            } else {
                minRight = min(nums1[i], nums2[j])
            }
            return float64(maxLeft + minRight) / 2.0
        }
    }
    return 0.0
}
```

#### [239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。

返回 *滑动窗口中的最大值* 。

**示例 1：**

```
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

**示例 2：**

```
输入：nums = [1], k = 1
输出：[1]
```

```go
func maxSlidingWindow(nums []int, k int) []int {
    q := []int{}
    i := 0
    for ; i < k; i++ {
        for len(q) > 0 && nums[q[len(q)-1]] < nums[i] {
            q = q[:len(q)-1]
        }
        q = append(q, i)
    }

    ans := []int{nums[q[0]]}
    for ; i < len(nums); i++ {
        for len(q) > 0 && nums[q[len(q)-1]] < nums[i] {
            q = q[:len(q)-1]
        }

        q = append(q, i)
        for k <= i - q[0] {
            q = q[1:]
        }
        ans = append(ans, nums[q[0]])
        
    }
    return ans
}
```

#### [440. 字典序的第K小数字](https://leetcode.cn/problems/k-th-smallest-in-lexicographical-order/)

给定整数 `n` 和 `k`，返回 `[1, n]` 中字典序第 `k` 小的数字。

**示例 1:**

```
输入: n = 13, k = 2
输出: 10
解释: 字典序的排列是 [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]，所以第二小的数字是 10。
```

**示例 2:**

```
输入: n = 1, k = 1
输出: 1
```

```go
 func findKthNumber(n int, k int) int {
    prefix := 1//前缀
    p := 1//作为一个指针，指向当前所在位置，当p==k时，也就是到了排位第k的数
    for p < k {
        cnt := getCnt(prefix, n)//1-n中以prefix为前缀的个数。
        
        if p+cnt > k {
            //第k个数在当前前缀下
            prefix *= 10
            p++//把指针指向了第一个子节点的位置，比如11乘10后变成110，指针从11指向了110
        } else if p+cnt <= k {
            //第k个数不在当前前缀下
            prefix++
            p += cnt//注意这里的操作，把指针指向了下一前缀的起点
        }
    }
    return prefix
}

//prefix是前缀，n是上界
func getCnt(prefix, n int) int {
    cur := prefix
    nxt := prefix+1//下一个前缀
    cnt := 0
    //当前的前缀当然不能大于上界
    for cur <= n {
        cnt += min(nxt, n+1)-cur //下一个前缀的起点减去当前前缀的起点
        cur *= 10
        nxt *= 10
        // 如果说刚刚prefix是1，next是2，那么现在分别变成10和20
        // 1为前缀的子节点增加10个，十叉树增加一层, 变成了两层
        
        // 如果说现在prefix是10，next是20，那么现在分别变成100和200，
        // 1为前缀的子节点增加100个，十叉树又增加了一层，变成了三层
    }
    return cnt //把当前前缀下的子节点和返回去。
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

#### [297. 二叉树的序列化与反序列化](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/)

序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。

请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。

**提示:** 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 [LeetCode 序列化二叉树的格式](https://leetcode.cn/faq/#binary-tree)。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg)

```
输入：root = [1,2,3,null,null,4,5]
输出：[1,2,3,null,null,4,5]
```

**示例 2：**

```
输入：root = []
输出：[]
```

**示例 3：**

```
输入：root = [1]
输出：[1]
```

**示例 4：**

```
输入：root = [1,2]
输出：[1,2]
```

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */

type Codec struct {
    
}

func Constructor() Codec {
    return Codec{}
}

// Serializes a tree to a single string.
func (c *Codec) serialize(root *TreeNode) string {
    if root == nil {
        return ""
    }
    ans := []string{}
    q := []*TreeNode{root}
    for len(q) > 0 {
        node := q[0]
        q = q[1:]
        if node == nil {
            ans = append(ans, "X")
            continue
        } else {
            s := strconv.Itoa(node.Val)
            ans = append(ans, s)
            q = append(q, node.Left)
            q = append(q, node.Right)
        }
    }
    return strings.Join(ans, ",")
}

// Deserializes your encoded data to tree.
func (c *Codec) deserialize(data string) *TreeNode {
    if len(data) == 0 {
        return nil
    }
    datas := strings.Split(data, ",")
    value, _ := strconv.Atoi(datas[0])
    root := newNode(value)
    q := []*TreeNode{root}
    for i := 1; i < len(datas); i+=2 {
        node := q[0]
        q = q[1:]
        if datas[i] == "X" {
            node.Left = nil
        } else {
            v, _ := strconv.Atoi(datas[i])
            node.Left = newNode(v)
            q = append(q, node.Left)
        }
        if datas[i + 1] == "X" {
            node.Right = nil
        } else {
            v, _ := strconv.Atoi(datas[i+1])
            node.Right = newNode(v)
            q = append(q, node.Right)
        }
    }
    return root
}

func newNode(v int) *TreeNode {
    return &TreeNode{
        Val: v,
    }
}


/**
 * Your Codec object will be instantiated and called as such:
 * ser := Constructor();
 * deser := Constructor();
 * data := ser.serialize(root);
 * ans := deser.deserialize(data);
 */
```

#### [135. 分发糖果](https://leetcode.cn/problems/candy/)

`n` 个孩子站成一排。给你一个整数数组 `ratings` 表示每个孩子的评分。

你需要按照以下要求，给这些孩子分发糖果：

- 每个孩子至少分配到 `1` 个糖果。
- 相邻两个孩子评分更高的孩子会获得更多的糖果。

请你给每个孩子分发糖果，计算并返回需要准备的 **最少糖果数目** 。

**示例 1：**

```
输入：ratings = [1,0,2]
输出：5
解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。
```

**示例 2：**

```
输入：ratings = [1,2,2]
输出：4
解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。
     第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。
```

```go
func candy(ratings []int) int {
    n := len(ratings)
    temp := make([]int, n)
    for i := 1; i < n; i++ {
        if ratings[i] > ratings[i - 1] {
            temp[i] = temp[i - 1] + 1
        }
    }
    for i := n - 2; i >= 0; i-- {
        if ratings[i] > ratings[i + 1] {
            if temp[i + 1] + 1 > temp[i] {
                temp[i] = temp[i + 1] + 1
            }
        }
    }
    has0 := 0
    sum := 0
    for i := 0; i < n; i++ {
        sum += temp[i]
        if temp[i] == 0 {
            has0 = 1
        }
    }
    return sum +  n * has0
}
```

## Hot100-200

#### [329. 矩阵中的最长递增路径](https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/)

给定一个 `m x n` 整数矩阵 `matrix` ，找出其中 **最长递增路径** 的长度。

对于每个单元格，你可以往上，下，左，右四个方向移动。 你 **不能** 在 **对角线** 方向上移动或移动到 **边界外**（即不允许环绕）。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/05/grid1.jpg)

```
输入：matrix = [[9,9,4],[6,6,8],[2,1,1]]
输出：4 
解释：最长递增路径为 [1, 2, 6, 9]。
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/01/27/tmp-grid.jpg)

```
输入：matrix = [[3,4,5],[3,2,6],[2,2,1]]
输出：4 
解释：最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。
```

**示例 3：**

```
输入：matrix = [[1]]
输出：1
```

```go
var dirx = []int{-1, 1, 0, 0}
var diry = []int{0, 0, 1, -1}
func longestIncreasingPath(matrix [][]int) int {
    m, n := len(matrix), len(matrix[0])
    nums := make([][]int, m)
    for i := 0; i < m; i++ {
        nums[i] = make([]int, n)
    }
    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            nums[i][j] = 1
        }
    }
    ans := 0
    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            ans = max(dfs(matrix, nums, i, j, m, n), ans)
        }
    }
    return ans
    
}

func dfs(matrix, nums [][]int, x, y int, row, cul int) int {
    if nums[x][y] > 1 {
        return nums[x][y]
    }
    
    for i := 0; i < 4; i++ {
        tx, ty := dirx[i] + x, diry[i] + y
        if tx >= 0 && ty >= 0 && tx < row && ty < cul && matrix[tx][ty] > matrix[x][y] {
            nums[x][y] = max(nums[x][y], dfs(matrix, nums, tx, ty, row, cul) + 1)
        }
    }
    return nums[x][y]

}


func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```

#### [224. 基本计算器](https://leetcode.cn/problems/basic-calculator/)

给你一个字符串表达式 `s` ，请你实现一个基本计算器来计算并返回它的值。

注意:不允许使用任何将字符串作为数学表达式计算的内置函数，比如 `eval()` 。

**示例 1：**

```
输入：s = "1 + 1"
输出：2
```

**示例 2：**

```
输入：s = " 2-1 + 2 "
输出：3
```

**示例 3：**

```
输入：s = "(1+(4+5+2)-3)+(6+8)"
输出：23
```

```go
func calculate(s string) int {
    t := []int{}
    num, ans, sign := 0, 0, 1
    for i := 0; i < len(s); i++ {
        if s[i] == ' ' {
            continue
        }
        if s[i] >= '0' && s[i] <= '9' {
            num = 10 * num + int(s[i]-'0')
        } else if s[i] == '+' {
            ans = ans + num * sign
            num = 0
            sign = 1
        } else if s[i] == '-' {
            ans = ans + num * sign
            num = 0
            sign = -1
        } else if s[i] == '(' {
            t = append(t, ans)
            t = append(t, sign)
            ans = 0
            sign = 1
        } else if s[i] == ')' {
            ans = ans + num * sign
            ans = ans * t[len(t)-1] + t[len(t)-2]
            t = t[:len(t)-2]
            num = 0
            sign = 1
        }
    }
    return ans + num * sign
}
```

#### [460. LFU 缓存](https://leetcode.cn/problems/lfu-cache/)

请你为 [最不经常使用（LFU）](https://baike.baidu.com/item/缓存算法)缓存算法设计并实现数据结构。

实现 `LFUCache` 类：

- `LFUCache(int capacity)` - 用数据结构的容量 `capacity` 初始化对象
- `int get(int key)` - 如果键 `key` 存在于缓存中，则获取键的值，否则返回 `-1` 。
- `void put(int key, int value)` - 如果键 `key` 已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量 `capacity` 时，则应该在插入新项之前，移除最不经常使用的项。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 **最近最久未使用** 的键。

为了确定最不常使用的键，可以为缓存中的每个键维护一个 **使用计数器** 。使用计数最小的键是最久未使用的键。

当一个键首次插入到缓存中时，它的使用计数器被设置为 `1` (由于 put 操作)。对缓存中的键执行 `get` 或 `put` 操作，使用计数器的值将会递增。

函数 `get` 和 `put` 必须以 `O(1)` 的平均时间复杂度运行。

**示例：**

```
输入：
["LFUCache", "put", "put", "get", "put", "get", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]
输出：
[null, null, null, 1, null, -1, 3, null, -1, 3, 4]

解释：
// cnt(x) = 键 x 的使用计数
// cache=[] 将显示最后一次使用的顺序（最左边的元素是最近的）
LFUCache lfu = new LFUCache(2);
lfu.put(1, 1);   // cache=[1,_], cnt(1)=1
lfu.put(2, 2);   // cache=[2,1], cnt(2)=1, cnt(1)=1
lfu.get(1);      // 返回 1
                 // cache=[1,2], cnt(2)=1, cnt(1)=2
lfu.put(3, 3);   // 去除键 2 ，因为 cnt(2)=1 ，使用计数最小
                 // cache=[3,1], cnt(3)=1, cnt(1)=2
lfu.get(2);      // 返回 -1（未找到）
lfu.get(3);      // 返回 3
                 // cache=[3,1], cnt(3)=2, cnt(1)=2
lfu.put(4, 4);   // 去除键 1 ，1 和 3 的 cnt 相同，但 1 最久未使用
                 // cache=[4,3], cnt(4)=1, cnt(3)=2
lfu.get(1);      // 返回 -1（未找到）
lfu.get(3);      // 返回 3
                 // cache=[3,4], cnt(4)=1, cnt(3)=3
lfu.get(4);      // 返回 4
                 // cache=[3,4], cnt(4)=2, cnt(3)=3
```

```go
type LFUCache struct {
	size     int
	capacity int
	minFreq  int
	cache    map[int]*LinkedNode
	freqMap  map[int]*LinkedList
}

type LinkedNode struct {
	key, value int
	freq       int
	prev, next *LinkedNode
}

type LinkedList struct {
	size       int
	head, tail *LinkedNode
}

func newLinkedNode(key, value int) *LinkedNode {
	return &LinkedNode{
		key:   key,
		value: value,
	}
}

func newLinkedList() *LinkedList {
	l := &LinkedList{
		size: 0,
		head: newLinkedNode(0, 0),
		tail: newLinkedNode(0, 0),
	}
	l.head.next = l.tail
	l.tail.prev = l.head
	return l
}

func Constructor(capacity int) LFUCache {
	c := LFUCache{
		capacity: capacity,
		cache:    map[int]*LinkedNode{},
		freqMap:  map[int]*LinkedList{},
	}
	return c
}

func (lfu *LFUCache) Get(key int) int {
	if node, ok := lfu.cache[key]; ok {
		lfu.updateFreq(node)
		return node.value
	}
	return -1
}

func (lfu *LFUCache) Put(key, value int) {
	if lfu.capacity == 0 {
		return
	}
	if node, ok := lfu.cache[key]; ok {
		lfu.updateFreq(node)
		node.value = value
		return
	}
	if lfu.size == lfu.capacity {
		lfu.removeMinFreqNode()
		lfu.size--
	}
	newNode := newLinkedNode(key, value)
	lfu.updateFreq(newNode)
	lfu.cache[key] = newNode
	lfu.size++
}

func (lfu *LFUCache) updateFreq(node *LinkedNode) {
	f := node.freq
	if f > 0 {
		lfu.freqMap[f].removeNode(node)
		lfu.freqMap[f].size--
		if lfu.freqMap[f].size == 0 {
			if lfu.minFreq == f {
				lfu.minFreq++
			}
			delete(lfu.freqMap, f)
		}
	} else {
		lfu.minFreq = 1
	}
	node.freq++
	if _, ok := lfu.freqMap[node.freq]; !ok {
		lfu.freqMap[node.freq] = newLinkedList()
	}
	lfu.freqMap[node.freq].addToTail(node)
	lfu.freqMap[node.freq].size++
}

func (lfu *LFUCache) removeMinFreqNode() {
	node := lfu.freqMap[lfu.minFreq].removeHead()
	delete(lfu.cache, node.key)
	lfu.freqMap[lfu.minFreq].size--
	if lfu.freqMap[lfu.minFreq].size == 0 {
		delete(lfu.freqMap, lfu.minFreq)
	}
}

func (lfu *LinkedList) removeNode(node *LinkedNode) {
	node.prev.next = node.next
	node.next.prev = node.prev
}

func (lfu *LinkedList) addToTail(node *LinkedNode) {
	lastNode := lfu.tail.prev
	lastNode.next = node
	node.prev = lastNode
	node.next = lfu.tail
	lfu.tail.prev = node
}

func (lfu *LinkedList) removeHead() *LinkedNode {
	node := lfu.head.next
	lfu.removeNode(node)
	return node
}
```

#### [123. 买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)

给定一个数组，它的第 `i` 个元素是一支给定的股票在第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 **两笔** 交易。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例 1:**

```
输入：prices = [3,3,5,0,0,3,1,4]
输出：6
解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
```

**示例 2：**

```
输入：prices = [1,2,3,4,5]
输出：4
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```

**示例 3：**

```
输入：prices = [7,6,4,3,1] 
输出：0 
解释：在这个情况下, 没有交易完成, 所以最大利润为 0。
```

**示例 4：**

```
输入：prices = [1]
输出：0
```

```go
func maxProfit(prices []int) int {
    dp := make([][][]int, len(prices))
    for i := 0; i < len(prices); i++ {
        dp[i] = make([][]int, 2)
        for j := 0; j < 2; j++ {
            dp[i][j] = make([]int, 3)
        }
    }
    for k := 0; k < 3; k++ {
        dp[0][0][k] = 0
        dp[0][1][k] = -prices[0]
    }
    for i := 1; i < len(prices); i++ {
        dp[i][0][0] = 0
        dp[i][0][1] = max(dp[i - 1][0][1], dp[i - 1][1][0] + prices[i])
        dp[i][0][2] = max(dp[i - 1][0][2], dp[i - 1][1][1] + prices[i])
        dp[i][1][0] = max(dp[i - 1][1][0], dp[i - 1][0][0] - prices[i])
        dp[i][1][1] = max(dp[i - 1][1][1], dp[i - 1][0][1] - prices[i])
        dp[i][1][2] = 0
    }
    return max(dp[len(prices) - 1][0][1], dp[len(prices) - 1][0][2])
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### [862. 和至少为 K 的最短子数组](https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/)

给你一个整数数组 `nums` 和一个整数 `k` ，找出 `nums` 中和至少为 `k` 的 **最短非空子数组** ，并返回该子数组的长度。如果不存在这样的 **子数组** ，返回 `-1` 。

**子数组** 是数组中 **连续** 的一部分。

**示例 1：**

```
输入：nums = [1], k = 1
输出：1
```

**示例 2：**

```
输入：nums = [1,2], k = 4
输出：-1
```

**示例 3：**

```
输入：nums = [2,-1,2], k = 3
输出：3
```

```go
func shortestSubarray(nums []int, k int) int {
    n := len(nums)
    sums := make([]int, n + 1)
    for i := 1; i < n + 1; i++ {
        sums[i] = sums[i-1] + nums[i-1]
    }
    ans := math.MaxInt32
    q := []int{}
    for i := 0; i < n + 1; i++ {
        for len(q) > 0 && sums[i] <= sums[q[len(q)-1]] {
            q = q[:len(q)-1]
        }
        for len(q) > 0 && sums[i] - sums[q[0]] >= k {
            ans = min(ans, i - q[0])
            q = q[1:]
        }

        q = append(q, i)
    }
    if ans == math.MaxInt32 {
        return -1
    }
    return ans
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}
```

#### [剑指 Offer 51. 数组中的逆序对](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)

在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。

**示例 1:**

```
输入: [7,5,6,4]
输出: 5
```

```go
func reversePairs(nums []int) int {
    if len(nums) < 2 { return 0 }
    ans := 0
    mergeSort(nums, 0, len(nums) - 1, &ans)
    return ans
}

func mergeSort(nums []int, l, r int, ans *int) {
    if l >= r {
        return
    }
    m := l + (r - l) / 2
    mergeSort(nums, l, m, ans)
    mergeSort(nums, m + 1, r, ans)
    merge(nums, l, m, r, ans)
}

func merge(nums []int, l, m, r int, ans *int) {
    temp := make([]int, r - l + 1)
    i, j := l, m + 1
    k := 0
    for ; i <= m && j <= r; k++ {
        if nums[i] <= nums[j] {
            temp[k] = nums[i]
            i++
        } else {
            // 在排序过程中，发现后一部分的值更小时，表示i~m这部分都是逆序对。
            *ans += m - i + 1
            temp[k] = nums[j]
            j++
        }
    }
    for ; i <= m; k++ {
        temp[k] = nums[i]
        i++
    }
    for ; j <= r; k++ {
        temp[k] = nums[j]
        j++
    }
    copy(nums[l: r+ 1], temp)
}
```

#### [10. 正则表达式匹配](https://leetcode.cn/problems/regular-expression-matching/)

给你一个字符串 `s` 和一个字符规律 `p`，请你来实现一个支持 `'.'` 和 `'*'` 的正则表达式匹配。

- `'.'` 匹配任意单个字符
- `'*'` 匹配零个或多个前面的那一个元素

所谓匹配，是要涵盖 **整个** 字符串 `s`的，而不是部分字符串。

**示例 1：**

```
输入：s = "aa", p = "a"
输出：false
解释："a" 无法匹配 "aa" 整个字符串。
```

**示例 2:**

```
输入：s = "aa", p = "a*"
输出：true
解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。
```

**示例 3：**

```
输入：s = "ab", p = ".*"
输出：true
解释：".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。
```

```go
func isMatch(s string, p string) bool {
	m, n := len(p), len(s)
	dp := make([][]bool, m+1)
	for i := 0; i < m+1; i++ {
		dp[i] = make([]bool, n+1)
	}
	dp[0][0] = true
	for i := 1; i < m+1; i++ {
		if p[i-1] == '*' {
			dp[i][0] = dp[i-2][0]
		}
	}
	for i := 1; i < m+1; i++ {
		for j := 1; j < n+1; j++ {
			if p[i-1] == s[j-1] {
				dp[i][j] = dp[i-1][j-1]
			} else if p[i-1] == '.' {
				dp[i][j] = dp[i-1][j-1]
			} else if p[i-1] == '*' {
				if p[i-2] == s[j-1] || p[i-2] == '.' {
					dp[i][j] = dp[i-2][j-1] || dp[i-2][j] || dp[i][j-1]
				} else {
					dp[i][j] = dp[i-2][j]
				}
			}
		}
	}
	return dp[m][n]
}
```

#### [887. 鸡蛋掉落](https://leetcode.cn/problems/super-egg-drop/)

给你 `k` 枚相同的鸡蛋，并可以使用一栋从第 `1` 层到第 `n` 层共有 `n` 层楼的建筑。

已知存在楼层 `f` ，满足 `0 <= f <= n` ，任何从 **高于** `f` 的楼层落下的鸡蛋都会碎，从 `f` 楼层或比它低的楼层落下的鸡蛋都不会破。

每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 `x` 扔下（满足 `1 <= x <= n`）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 **重复使用** 这枚鸡蛋。

请你计算并返回要确定 `f` **确切的值** 的 **最小操作次数** 是多少？

**示例 1：**

```
输入：k = 1, n = 2
输出：2
解释：
鸡蛋从 1 楼掉落。如果它碎了，肯定能得出 f = 0 。 
否则，鸡蛋从 2 楼掉落。如果它碎了，肯定能得出 f = 1 。 
如果它没碎，那么肯定能得出 f = 2 。 
因此，在最坏的情况下我们需要移动 2 次以确定 f 是多少。 
```

**示例 2：**

```
输入：k = 2, n = 6
输出：3
```

**示例 3：**

```
输入：k = 3, n = 14
输出：4
```

```go
func superEggDrop(k int, n int) int {
    visited := make([][]int, k + 1)
    for i := 0; i < k + 1; i++ {
        visited[i] = make([]int, n + 1)
    }
    var dp func(k, n int) int
    dp = func(k, n int) int {
        if k == 1 {
            return n
        }
        if n == 0 {
            return n
        }
        if visited[k][n] != 0 {
            return visited[k][n]
        }
        l, r := 1, n
        res := n
        for l <= r {
            m := (l + r) / 2
            broken := dp(k - 1, m - 1)
            noBroken := dp(k, n - m)
            if broken > noBroken {
                r = m - 1
                res = min(res, broken + 1)
            } else {
                l = m + 1
                res = min(res, noBroken + 1)
            }
            
        }
        visited[k][n] = res

        return res
    }
    return dp(k, n)
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

优质代码：

```go
func superEggDrop(k int, n int) int {
    var dfs func(a int,b int)int
    dfs = func(a int,b int)int{
        if a == 1 || b == 1{
            return b + 1
        }
        return dfs(a - 1,b - 1) + dfs(a , b - 1)
    }
    loc := 1
    for dfs(k , loc) <= n{
        loc++
    }
    return loc
}
```

#### [188. 买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)

给定一个整数数组 `prices` ，它的第 `i` 个元素 `prices[i]` 是一支给定的股票在第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 **k** 笔交易。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例 1：**

```
输入：k = 2, prices = [2,4,1]
输出：2
解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。
```

**示例 2：**

```
输入：k = 2, prices = [3,2,6,5,0,3]
输出：7
解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。
     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。
```

```go
func maxProfit(kMax int, prices []int) int {
    if len(prices) < 2 {return 0}
    dp := make([][][]int, len(prices))
    for i := 0; i < len(prices); i++ {
        dp[i] = make([][]int, 2)
        for j := 0; j < 2; j++ {
            dp[i][j] = make([]int, kMax + 1)
        }
    }
    for i := 0; i <= kMax; i++ {
        dp[0][0][i] = 0
        dp[0][1][i] = -prices[0]
    }

    for i := 1; i < len(prices); i++ {
        for k := 0; k <= kMax; k++ {
            if k > 0 {
                dp[i][0][k] = max(dp[i - 1][0][k], dp[i - 1][1][k - 1] + prices[i])
            }
            dp[i][1][k] = max(dp[i - 1][1][k], dp[i - 1][0][k] - prices[i])
        }
        dp[i][0][0] = 0
        dp[i][1][kMax] = 0
    }
    ans := 0
    for k := 0; k <= kMax; k++ {
        if dp[len(prices) - 1][0][k] > ans {
            ans = dp[len(prices) - 1][0][k]
        }
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### [295. 数据流的中位数](https://leetcode.cn/problems/find-median-from-data-stream/)

中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。

例如，

[2,3,4] 的中位数是 3

[2,3] 的中位数是 (2 + 3) / 2 = 2.5

设计一个支持以下两种操作的数据结构：

- void addNum(int num) - 从数据流中添加一个整数到数据结构中。
- double findMedian() - 返回目前所有元素的中位数。

**示例：**

```
addNum(1)
addNum(2)
findMedian() -> 1.5
addNum(3) 
findMedian() -> 2
```

```go
type MedianFinder struct {
    lowheap []int // 大顶堆，存小数
    highheap []int // 小顶堆，存大数
}


func Constructor() MedianFinder {
    return MedianFinder{
        lowheap: []int{0},
        highheap: []int{0},
    }
}


func (m *MedianFinder) AddNum(num int)  {
    l1, l2 := len(m.lowheap), len(m.highheap)
    t1, t2 := 0, 0
    if l1 > 1 {
        t1 = m.lowheap[1]
    }
    if l2 > 1 {
        t2 = m.highheap[1]
    }
    if l1 == l2 {
        if num >= t1 {
            m.highheap = append(m.highheap, num)
            SmallHeapBot2Top(m.highheap)
        } else if num < t2 {
            m.lowheap = append(m.lowheap, num)
            LargeHeapBot2Top(m.lowheap)
        }
    } else if l1 > l2 {
        if num >= t1 {
            m.highheap = append(m.highheap, num)
            SmallHeapBot2Top(m.highheap)
        } else {
            m.highheap = append(m.highheap, t1)
            SmallHeapBot2Top(m.highheap)
            m.lowheap[1] = num
            LargeHeapTop2Bot(m.lowheap)
        }
    } else if l2 > l1 {
        if num < t2 {
            m.lowheap = append(m.lowheap, num)
            LargeHeapBot2Top(m.lowheap)
        } else {
            m.lowheap = append(m.lowheap, t2)
            LargeHeapBot2Top(m.lowheap)
            m.highheap[1] = num
            SmallHeapTop2Bot(m.highheap)
        }
    }
}


func (m *MedianFinder) FindMedian() float64 {
    l1, l2 := len(m.lowheap), len(m.highheap)
    var result float64
    if l1 > l2 {
        result =  float64(m.lowheap[1])
    } else if l1 < l2 {
        result =  float64(m.highheap[1])
    } else {
        result = (float64(m.lowheap[1])+float64(m.highheap[1])) / 2.0
    }
    return result
    
}

//大顶堆 自上而下调整算法
func LargeHeapTop2Bot(heap []int) {
    length := len(heap)-1
    i := 1
	for i <= length {
		maxidx := i
        if i * 2 <= length && heap[i] < heap[i*2] {
            maxidx = 2 * i
        }
        if i * 2 + 1 <= length && heap[maxidx] < heap[i*2 + 1] {
            maxidx = 2 * i + 1
        }
        if i == maxidx {
            break
        }
        heap[i], heap[maxidx] = heap[maxidx], heap[i]
        i = maxidx
	}
}
//大顶堆 自下而上调整算法
func LargeHeapBot2Top(heap []int) {
    i := len(heap)-1
    for i / 2 > 0 && heap[i / 2] < heap[i] {
		heap[i], heap[i / 2] = heap[i / 2], heap[i]
		i = i / 2
	}
}

//小顶堆 自上而下调整算法
func SmallHeapTop2Bot(heap []int) {
    length := len(heap)-1
    i := 1
	for i <= length {
		minidx := i
        if i * 2 <= length && heap[i] > heap[i*2] {
            minidx = 2 * i
        }
        if i * 2 + 1 <= length && heap[minidx] > heap[i*2 + 1] {
            minidx = 2 * i + 1
        }
        if i == minidx {
            break
        }
        heap[i], heap[minidx] = heap[minidx], heap[i]
        i = minidx
	}
}
//小顶堆 自下而上调整算法
func SmallHeapBot2Top(heap []int) {
    i := len(heap)-1
    for i / 2 > 0 && heap[i / 2] > heap[i] {
		heap[i], heap[i / 2] = heap[i / 2], heap[i]
		i = i / 2
	}
}
```

#### [85. 最大矩形](https://leetcode.cn/problems/maximal-rectangle/)

给定一个仅包含 `0` 和 `1` 、大小为 `rows x cols` 的二维二进制矩阵，找出只包含 `1` 的最大矩形，并返回其面积。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg)

```
输入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
输出：6
解释：最大矩形如上图所示。
```

**示例 2：**

```
输入：matrix = []
输出：0
```

**示例 3：**

```
输入：matrix = [["0"]]
输出：0
```

**示例 4：**

```
输入：matrix = [["1"]]
输出：1
```

**示例 5：**

```
输入：matrix = [["0","0"]]
输出：0
```

```go
func maximalRectangle(matrix [][]byte) int {
    ans := 0
    if len(matrix) == 0 {
        return ans
    }
    m, n := len(matrix), len(matrix[0])
    heights := make([]int, n)
    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            if matrix[i][j] == '1' {
                heights[j] += 1
            } else {
                heights[j] = 0
            }
        }
        ans = max(ans, largestRectangleArea(heights))
    }
    return ans
}

func largestRectangleArea(heights []int) int {
    ary := []int{0}
    ary = append(ary, heights...)
    ary = append(ary, 0)
    // 存索引
    stk := []int{}
    ans := 0
    for i := 0; i < len(ary); i++ {
        for len(stk) != 0 && ary[i] < ary[stk[len(stk) - 1]] {
            idx := stk[len(stk) - 2]
            // 因为是单调增的栈，idx和i之间都是更高的柱子。所以长度要i-idx-1
            ans = max(ans, ary[stk[len(stk) - 1]] * (i - idx - 1))
            stk = stk[:len(stk) - 1]
        }
        stk = append(stk, i)
    }
    return ans
}

func max(x, y int) int {
    if x > y {
        return x
    }
    return y
}
```

#### [44. 通配符匹配](https://leetcode.cn/problems/wildcard-matching/)

给定一个字符串 (`s`) 和一个字符模式 (`p`) ，实现一个支持 `'?'` 和 `'*'` 的通配符匹配。

```
'?' 可以匹配任何单个字符。
'*' 可以匹配任意字符串（包括空字符串）。
```

两个字符串**完全匹配**才算匹配成功。

**说明:**

- `s` 可能为空，且只包含从 `a-z` 的小写字母。
- `p` 可能为空，且只包含从 `a-z` 的小写字母，以及字符 `?` 和 `*`。

**示例 1:**

```
输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。
```

**示例 2:**

```
输入:
s = "aa"
p = "*"
输出: true
解释: '*' 可以匹配任意字符串。
```

**示例 3:**

```
输入:
s = "cb"
p = "?a"
输出: false
解释: '?' 可以匹配 'c', 但第二个 'a' 无法匹配 'b'。
```

**示例 4:**

```
输入:
s = "adceb"
p = "*a*b"
输出: true
解释: 第一个 '*' 可以匹配空字符串, 第二个 '*' 可以匹配字符串 "dce".
```

**示例 5:**

```
输入:
s = "acdcb"
p = "a*c?b"
输出: false
```

```go
func isMatch(s string, p string) bool {
    m, n := len(p), len(s)
    dp := make([][]bool, m + 1)
    for i := 0; i < m + 1; i++ {
        dp[i] = make([]bool, n + 1)
    }
    for i := 1; i < m+1; i++ {
        if p[i-1] == '*' {
            dp[i][0] = true
        } else {
            break
        }
    }
    dp[0][0] = true
    for i := 1; i < m+1; i++ {
        for j := 1; j < n + 1; j++ {
            if s[j-1] == p[i-1] || p[i-1] == '?' {
                dp[i][j] = dp[i-1][j-1]
            } else if p[i-1] == '*' {
                dp[i][j] = dp[i-1][j] || dp[i][j-1]
            }
        }
    }
    return dp[m][n]
    
}
```

#### [340. 至多包含 K 个不同字符的最长子串](https://leetcode.cn/problems/longest-substring-with-at-most-k-distinct-characters/)

给定一个字符串 ***`s`\*** ，找出 **至多** 包含 *`k`* 个不同字符的最长子串 ***T\***。

**示例 1:**

```
输入: s = "eceba", k = 2
输出: 3
解释: 则 T 为 "ece"，所以长度为 3。
```

**示例 2:**

```
输入: s = "aa", k = 1
输出: 2
解释: 则 T 为 "aa"，所以长度为 2。
```

```go
func lengthOfLongestSubstringKDistinct(s string, k int) int {
	hasMap :=map[byte]int{}
	maxs :=math.MinInt32
	//分别代表左，右窗口的左右边界
	left,right :=0,0
	for right <len(s){
		//出现次数肯定想到哈希表
		hasMap[s[right]]++
		right++
		//哈希表存入的元素大于k的时候就开始减，减到0就删除，然后缩短左边界
		for len(hasMap) >k{
			//删除左边界元素
			hasMap[s[left]]--
			if 0 ==hasMap[s[left]] {
				delete(hasMap,s[left])
			}
			left++
		}
		//right-left就是最长的大小字串，
		//这个maxs是动态变化的，始终保持的是最大字串的长度
		maxs =max(maxs,right-left)
	}
	return maxs
}

func max(a,b int)int{
	if a>b {
		return a
	}else{
		return b
	}
}

```

## Hot200-300

#### [84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)

给定 *n* 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。

**示例 1:**

![img](https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg)

```
输入：heights = [2,1,5,6,2,3]
输出：10
解释：最大的矩形为图中红色区域，面积为 10
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg)

```
输入： heights = [2,4]
输出： 4
```

```go
func largestRectangleArea(heights []int) int {
    ary := []int{0}
    ary = append(ary, heights...)
    ary = append(ary, 0)
    q := []int{}
    ans := 0
    for i := 0; i < len(ary); i++ {
        for len(q) > 0 && ary[i] < ary[q[len(q)-1]] {
            left := q[len(q)-2]
            ans = max(ans, ary[q[len(q)-1]] * (i - left - 1))
            q = q[:len(q)-1]
        }
        q = append(q, i)
    }
    return ans
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```

#### [154. 寻找旋转排序数组中的最小值 II](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/)

已知一个长度为 `n` 的数组，预先按照升序排列，经由 `1` 到 `n` 次 **旋转** 后，得到输入数组。例如，原数组 `nums = [0,1,4,4,5,6,7]` 在变化后可能得到：

- 若旋转 `4` 次，则可以得到 `[4,5,6,7,0,1,4]`
- 若旋转 `7` 次，则可以得到 `[0,1,4,4,5,6,7]`

注意，数组 `[a[0], a[1], a[2], ..., a[n-1]]` **旋转一次** 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]` 。

给你一个可能存在 **重复** 元素值的数组 `nums` ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 **最小元素** 。

你必须尽可能减少整个过程的操作步骤。

**示例 1：**

```
输入：nums = [1,3,5]
输出：1
```

**示例 2：**

```
输入：nums = [2,2,2,0,1]
输出：0
```

```go
func findMin(nums []int) int {
    l, r := 0, len(nums)-1
    for l < r {
        m := (l + r) / 2
        if (nums[m] > nums[r]) {          
            l = m + 1
        } else if nums[m] < nums[r] {                               
            r = m;
        } else {
            r--
        }
    }
    return nums[l]
}
```

#### [679. 24 点游戏](https://leetcode.cn/problems/24-game/)

给定一个长度为4的整数数组 `cards` 。你有 `4` 张卡片，每张卡片上都包含一个范围在 `[1,9]` 的数字。您应该使用运算符 `['+', '-', '*', '/']` 和括号 `'('` 和 `')'` 将这些卡片上的数字排列成数学表达式，以获得值24。

你须遵守以下规则:

- 除法运算符

    ```
    '/'
    ```

    表示实数除法，而不是整数除法。

    - 例如， `4 /(1 - 2 / 3)= 4 /(1 / 3)= 12` 。

- 每个运算都在两个数字之间。特别是，不能使用

    ```
    “-”
    ```

    作为一元运算符。

    - 例如，如果 `cards =[1,1,1,1]` ，则表达式 `“-1 -1 -1 -1”` 是 **不允许** 的。

- 你不能把数字串在一起

    - 例如，如果 `cards =[1,2,1,2]` ，则表达式 `“12 + 12”` 无效。

如果可以得到这样的表达式，其计算结果为 `24` ，则返回 `true `，否则返回 `false` 。

**示例 1:**

```
输入: cards = [4, 1, 8, 7]
输出: true
解释: (8-4) * (7-1) = 24
```

**示例 2:**

```
输入: cards = [1, 2, 1, 2]
输出: false
```

```go
func judgePoint24(cards []int) bool {
    nums := make([]float64, len(cards))
    for i := 0; i < len(cards); i++ {
        nums[i] = float64(cards[i])
    }
    return dfs(nums)
}

func dfs(nums []float64) bool {
    // 递归处理，nums中每两个数变成1个数，然后重新递归，直到只剩1个数
    if len(nums) == 1 {
        if math.Abs(nums[0]-24) < 1e-9 {
            return true
        }
    }
    l := len(nums)
    ans := false
    for i := 0; i < l; i++ {
        for j := i + 1; j < l; j++ {
            newNums := make([]float64, 0, l)
            for k := 0; k < l; k++ {
                if k != i && k != j {
                    newNums = append(newNums, nums[k])
                }
            }
            n1, n2 := nums[i], nums[j]
            ans = ans || dfs(append(newNums, n1 + n2))
            ans = ans || dfs(append(newNums, n1 - n2))
            ans = ans || dfs(append(newNums, n2 - n1))
            ans = ans || dfs(append(newNums, n1 * n2))
            if n1 != 0 {
                ans = ans || dfs(append(newNums, n2 / n1))
            }
            if n2 != 0 {
                ans = ans || dfs(append(newNums, n1 / n2))
            }
            if ans {
                return true
            }
        }
    }
    return ans
}
```

#### [1044. 最长重复子串](https://leetcode.cn/problems/longest-duplicate-substring/)

给你一个字符串 `s` ，考虑其所有 *重复子串* ：即 `s` 的（连续）子串，在 `s` 中出现 2 次或更多次。这些出现之间可能存在重叠。

返回 **任意一个** 可能具有最长长度的重复子串。如果 `s` 不含重复子串，那么答案为 `""` 。

**示例 1：**

```
输入：s = "banana"
输出："ana"
```

**示例 2：**

```
输入：s = "abcd"
输出：""
```

```go
func longestDupSubstring(s string) string {
    n := len(s)
    l, r := 0, n-1
    ans := ""
    // 先查找存在重复子串的长度，通过二分法查找长度会比遍历更快。
    // 这里的二分逻辑相当于求满足条件的最大值。
    for l <= r {
        m := (l + r) / 2
        if check(s, m, &ans) {
            l = m + 1
        } else {
            r = m - 1
        }
    }
    return ans
}

func check(s string, m int, ans *string) bool {
    // 用map存遍历过的子串，如果有重复的，表示m长度下有重复子串。
    visited := map[string]bool{}
    for i := 0; i < len(s) - m + 1; i++ {
        cur := s[i:i+m]
        if visited[cur] {
            *ans = cur
            return true
        } else {
            visited[cur] = true
        }
    }
    return false
}
```

#### [51. N 皇后](https://leetcode.cn/problems/n-queens/)

按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。

**n 皇后问题** 研究的是如何将 `n` 个皇后放置在 `n×n` 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 `n` ，返回所有不同的 **n 皇后问题** 的解决方案。

每一种解法包含一个不同的 **n 皇后问题** 的棋子放置方案，该方案中 `'Q'` 和 `'.'` 分别代表了皇后和空位。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/13/queens.jpg)

```
输入：n = 4
输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
解释：如上图所示，4 皇后问题存在两个不同的解法。
```

**示例 2：**

```
输入：n = 1
输出：[["Q"]]
```

```go
func solveNQueens(n int) [][]string {
    ans := [][]string{}
    board := initBoard(n)
    var dfs func(row int)
    dfs = func(row int) {
        if row == n {
            ans = append(ans, byte2string(board))
            return
        }
        
        for col := 0; col < n; col++ {
            if isValid(board, row, col) {
                board[row][col] = 'Q'
                dfs(row + 1)
                board[row][col] = '.'
            }
        }
    }
    dfs(0)
    return ans
}

func initBoard(n int) [][]byte {
    board := make([][]byte, n)
    for i := 0; i < n; i++ {
        board[i] = make([]byte, n)
        for j := 0; j < n; j++ {
            board[i][j] = '.'
        }
    }
    return board
}

func byte2string(board [][]byte) []string {
    n := len(board)
    ans := []string{}
    for i := 0; i < n; i++ {
        ans = append(ans, string(board[i]))
    }
    return ans
}

func isValid(board [][]byte, row int, col int) bool {
    n := len(board)
    for i := 0; i < row; i++ {
        for j := 0; j < n; j++ {
            if board[i][j] == 'Q' && (j == col || i - row == j - col || i - row == col - j) {
                return false
            }
        }
    }
    return true
}
```

#### [面试题 17.24. 最大子矩阵](https://leetcode.cn/problems/max-submatrix-lcci/)

给定一个正整数、负整数和 0 组成的 N × M 矩阵，编写代码找出元素总和最大的子矩阵。

返回一个数组 `[r1, c1, r2, c2]`，其中 `r1`, `c1` 分别代表子矩阵左上角的行号和列号，`r2`, `c2` 分别代表右下角的行号和列号。若有多个满足条件的子矩阵，返回任意一个均可。

**注意：**本题相对书上原题稍作改动

**示例：**

```
输入：
[
   [-1,0],
   [0,-1]
]
输出：[0,1,0,1]
解释：输入中标粗的元素即为输出所表示的矩阵
```

```go
func getMaxMatrix(matrix [][]int) []int {
    // 前缀和+最大子数组和
    m, n := len(matrix), len(matrix[0])
    // 先求每列的前缀和
    presum := make([][]int, m)
    for i := 0; i < m; i++ {
        presum[i] = make([]int, n)
    }
    for i := 0; i < n; i++ {
        presum[0][i] = matrix[0][i]
    }
    for i := 1; i < m; i++ {
        for j := 0; j < n; j++ {
            presum[i][j] = presum[i-1][j] + matrix[i][j]
        }
    }
    maxsum := matrix[0][0]
    r1, c1, r2, c2 := 0, 0, 0, 0
    // 固定[i, j]作为子矩阵的上界和下界。
    for i := 0; i < m; i++ {
        for j := i; j < m; j++ {
            // sum是[i, j]的每列和
            sums := make([]int, n)
            for k := 0; k < n; k++ {
                if i == 0 {
                    sums[k] = presum[j][k]
                } else {
                    sums[k] = presum[j][k] - presum[i-1][k]
                }
            }
            // 后续就是求最大子数组和，注意保存left边
            sum := 0
            left := 0
            for k := 0; k < n; k++ {
                sum += sums[k]
                if sum > maxsum {
                    r1, r2 = i, j
                    c1, c2 = left, k
                    maxsum = sum
                }
                if sum < 0 {
                    left = k+1
                    sum = 0
                }
            }
        }
    }
    return []int{r1, c1, r2, c2}
}
```

#### [772. 基本计算器 III](https://leetcode.cn/problems/basic-calculator-iii/)

实现一个基本的计算器来计算简单的表达式字符串。

表达式字符串只包含非负整数，算符 `+`、`-`、`*`、`/` ，左括号 `(` 和右括号 `)` 。整数除法需要 **向下截断** 。

你可以假定给定的表达式总是有效的。所有的中间结果的范围为 `[-231, 231 - 1]` 。

**示例 1：**

```
输入：s = "1+1"
输出：2
```

**示例 2：**

```
输入：s = "6-4/2"
输出：4
```

**示例 3：**

```
输入：s = "2*(5+5*2)/3+(6/2+8)"
输出：21
```

**示例 4：**

```
输入：s = "(2+6*3+5-(3*14/7+2)*5)+3"
输出：-12
```

**示例 5：**

```
输入：s = "0"
输出：0
```

```go
func calculate(s string) int {
    // 各个符号的优先级
    priority := map[string]int {
        "(":0, "*":1, "/":1, "+":2, "-":2,
    }  //优先级
    nums, ops := []int{}, []string{}
    var num, x, y int
    var opt string
    cur := 0

    for cur < len(s) {
        if 48 <= s[cur] && s[cur] <= 57 {
            num = 0
            for cur < len(s) && 48 <= s[cur] && s[cur] <= 57 {
                num = num * 10 + int(s[cur] - 48)
                cur ++
            }
            nums = append(nums, num)
            continue
        } else if string(s[cur]) == "(" {
            ops = append(ops, string(s[cur]))
        } else if string(s[cur]) == ")" {
            //把括号内的全部算完
            for len(ops) > 0 && priority[ops[len(ops)-1]] > 0 {
                x, y, opt = nums[len(nums) - 2], nums[len(nums) - 1], ops[len(ops) - 1]
                nums, ops = nums[:len(nums) - 2], ops[:len(ops) - 1]
                nums = append(nums, cal(x, y, opt))
            }
            ops = ops[:len(ops) - 1]  //去掉最后一个左括号
        } else {
            //把上一个左括号前的，并且优先级比自己大或等于自己的算完
            for len(ops) > 0 && ops[len(ops) - 1] != "(" && priority[ops[len(ops)-1]] <= priority[string(s[cur])] {
                x, y, opt = nums[len(nums) - 2], nums[len(nums) - 1], ops[len(ops) - 1]
                nums, ops = nums[:len(nums) - 2], ops[:len(ops) - 1]
                nums = append(nums, cal(x, y, opt))
            }
            ops = append(ops, string(s[cur]))
        }
        cur ++
    }

    //按序处理剩下的
    for len(ops) > 0 {
        x, y, opt = nums[len(nums) - 2], nums[len(nums) - 1], ops[len(ops) - 1]
        nums, ops = nums[:len(nums) - 2], ops[:len(ops) - 1]
        nums = append(nums, cal(x, y, opt))
    }
    
    return nums[0]
}

//返回计算结果
func cal (x int, y int, opt string) int {
    if opt == "+" {
        return x + y
    } else if opt == "-" {
        return x - y
    } else if opt == "*" {
        return x * y
    } else {
        return x / y
    }
}
```

#### [149. 直线上最多的点数](https://leetcode.cn/problems/max-points-on-a-line/)

给你一个数组 `points` ，其中 `points[i] = [xi, yi]` 表示 **X-Y** 平面上的一个点。求最多有多少个点在同一条直线上。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/25/plane1.jpg)

```
输入：points = [[1,1],[2,2],[3,3]]
输出：3
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/02/25/plane2.jpg)

```
输入：points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]
输出：4
```

```go
func maxPoints(points [][]int) int {
    // x y z三点在一条直线上，就统计出来，遍历所有点就行了。
	n := len(points)
	ans := 1
	for i := 0; i < n; i++ {
		x := points[i]
		for j := i + 1; j < n; j++ {
			y := points[j]
			cnt := 2
			for k := j + 1; k < n; k++ {
                // x y的斜率 == y z的斜率 就视为三点在一条直线。
                // 计算的s1和s2，就是斜率的变形。因为计算斜率是 / ，避免误差变形为*
				z := points[k]
				s1 := (x[0] - y[0]) * (y[1] - z[1])
				s2 := (x[1] - y[1]) * (y[0] - z[0])
				if s1 == s2 {
					cnt++
				}
			}
			ans = max(ans, cnt)
		}
	}
	return ans
}

func max(a, b int) int {
	if a > b {
        return a
    }
	return b
}
```

#### [1312. 让字符串成为回文串的最少插入次数](https://leetcode.cn/problems/minimum-insertion-steps-to-make-a-string-palindrome/)

给你一个字符串 `s` ，每一次操作你都可以在字符串的任意位置插入任意字符。

请你返回让 `s` 成为回文串的 **最少操作次数** 。

「回文串」是正读和反读都相同的字符串。

**示例 1：**

```
输入：s = "zzazz"
输出：0
解释：字符串 "zzazz" 已经是回文串了，所以不需要做任何插入操作。
```

**示例 2：**

```
输入：s = "mbadm"
输出：2
解释：字符串可变为 "mbdadbm" 或者 "mdbabdm" 。
```

**示例 3：**

```
输入：s = "leetcode"
输出：5
解释：插入 5 个字符后字符串变为 "leetcodocteel" 。
```

```go
func minInsertions(s string) int {
    l := len(s)
    dp := make([][]int, l)
    for i := 0; i < l; i++ {
        dp[i] = make([]int, l)
    }
    for j := 1; j < l; j++ {
        for i := j - 1; i >= 0; i-- {
            if s[i] == s[j] {
                dp[i][j] = dp[i + 1][j - 1] 
            } else {
                dp[i][j] = min(dp[i][j - 1], dp[i + 1][j]) + 1
            }
        }
    }
    return dp[0][l - 1]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

#### [786. 第 K 个最小的素数分数](https://leetcode.cn/problems/k-th-smallest-prime-fraction/)

给你一个按递增顺序排序的数组 `arr` 和一个整数 `k` 。数组 `arr` 由 `1` 和若干 **素数** 组成，且其中所有整数互不相同。

对于每对满足 `0 <= i < j < arr.length` 的 `i` 和 `j` ，可以得到分数 `arr[i] / arr[j]` 。

那么第 `k` 个最小的分数是多少呢? 以长度为 `2` 的整数数组返回你的答案, 这里 `answer[0] == arr[i]` 且 `answer[1] == arr[j]` 。

**示例 1：**

```
输入：arr = [1,2,3,5], k = 3
输出：[2,5]
解释：已构造好的分数,排序后如下所示: 
1/5, 1/3, 2/5, 1/2, 3/5, 2/3
很明显第三个最小的分数是 2/5
```

**示例 2：**

```
输入：arr = [1,7], k = 1
输出：[1,7]
```

```go
// 构建小顶堆
type item struct {
    x int // arr中，i位置的元素
    y int // arr中，j位置的元素
    i int // arr中，i索引
    j int // arr中，j索引
}
type hp []item
func (h hp) Len() int            { return len(h) }
func (h hp) Less(i, j int) bool  { return h[i].x*h[j].y < h[i].y*h[j].x } // 小顶堆条件，x/y的大小
func (h hp) Swap(i, j int)       { h[i], h[j] = h[j], h[i] }
func (h *hp) Push(v interface{}) { *h = append(*h, v.(item)) }
func (h *hp) Pop() interface{}   { a := *h; v := a[len(a)-1]; *h = a[:len(a)-1]; return v }

func kthSmallestPrimeFraction(arr []int, k int) []int {
    n := len(arr)
    // 初始化一个小顶堆，先把分子为1的数放入堆中。
    h := make(hp, n-1)
    for j := 1; j < n; j++ {
        h[j-1] = item{arr[0], arr[j], 0, j}
    }
    heap.Init(&h)
    
    for p := k - 1; p > 0; p-- {
        // 还没到第k小，所以把pop出最小节点。
        f := heap.Pop(&h).(item)
        // 因为是递增数组，一定arr[i+1]/arr[j] > arr[i]/arr[j](f节点)，没存入堆中的节点也一定比顶点大。
        if f.i+1 < f.j {
            // 不断添加节点。
            heap.Push(&h, item{arr[f.i+1], f.y, f.i+1, f.j})
        }
    }
    // 节点进进出出结束后，输出剩下的顶点，没push进堆中的节点，一定都比顶点大。
    return []int{h[0].x, h[0].y}
}
```

#### [301. 删除无效的括号](https://leetcode.cn/problems/remove-invalid-parentheses/)

给你一个由若干括号和字母组成的字符串 `s` ，删除最小数量的无效括号，使得输入的字符串有效。

返回所有可能的结果。答案可以按 **任意顺序** 返回。

**示例 1：**

```
输入：s = "()())()"
输出：["(())()","()()()"]
```

**示例 2：**

```
输入：s = "(a)())()"
输出：["(a())()","(a)()()"]
```

**示例 3：**

```
输入：s = ")("
输出：[""]
```

```go
func removeInvalidParentheses(s string) []string {
    // 先求要删除的左右括号个数。
    lrm, rrm := 0, 0
    for _, t := range s {
        if t == '(' {
            lrm++
        } else if t == ')' {
            if lrm == 0 {
                rrm++
            } else {
                lrm--
            }
        }
    }
    ans := []string{}
    helper(&ans, s, 0, lrm, rrm)
    return ans
}

func isvalid(s string) bool {
    cnt := 0
    for _, t := range s {
        if t == '(' {
            cnt++
        } else if t == ')' {
            cnt--
            if cnt < 0 {
                return false
            }
        }
    }
    return cnt == 0
}

func helper(ans *[]string, s string, start int, lrm, rrm int) {
    if lrm == 0 && rrm == 0 {
        // 括号删干净后，有可能出现类似)(这种情况，需要过滤掉
        if isvalid(s) {
            *ans = append(*ans, s)
        }
        return
    }
    for i := start; i < len(s); i++ {
        // 避免重复计算，连续一样的，处理一个就行了。
        if i != start && s[i] == s[i-1] {
            continue
        }
        // 剩下的位置不够删。
        if lrm + rrm > len(s)-i {
            return
        }
        // 先删左括号
        if lrm > 0 && s[i] == '(' {
            helper(ans, s[:i] + s[i+1:], i, lrm-1, rrm)
        }
        // 再删右括号
        if rrm > 0 && s[i] == ')' {
            helper(ans, s[:i]+s[i+1:], i, lrm, rrm-1)
        }
    }
}
```

## Hot300-

#### [164. 最大间距](https://leetcode.cn/problems/maximum-gap/)

给定一个无序的数组 `nums`，返回 *数组在排序之后，相邻元素之间最大的差值* 。如果数组元素个数小于 2，则返回 `0` 。

您必须编写一个在「线性时间」内运行并使用「线性额外空间」的算法。

**示例 1:**

```
输入: nums = [3,6,9,1]
输出: 3
解释: 排序后的数组是 [1,3,6,9], 其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3。
```

**示例 2:**

```
输入: nums = [10]
输出: 0
解释: 数组元素个数小于 2，因此返回 0。
```

```

```

#### [99. 恢复二叉搜索树](https://leetcode.cn/problems/recover-binary-search-tree/)

给你二叉搜索树的根节点 `root` ，该树中的 **恰好** 两个节点的值被错误地交换。*请在不改变其结构的情况下，恢复这棵树* 。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/28/recover1.jpg)

```
输入：root = [1,3,null,null,2]
输出：[3,1,null,null,2]
解释：3 不能是 1 的左孩子，因为 3 > 1 。交换 1 和 3 使二叉搜索树有效。
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/10/28/recover2.jpg)

```
输入：root = [3,1,4,null,null,2]
输出：[2,1,4,null,null,3]
解释：2 不能在 3 的右子树中，因为 2 < 3 。交换 2 和 3 使二叉搜索树有效。
```

```go

```

#### [895. 最大频率栈](https://leetcode.cn/problems/maximum-frequency-stack/)

设计一个类似堆栈的数据结构，将元素推入堆栈，并从堆栈中弹出**出现频率**最高的元素。

实现 `FreqStack` 类:

- `FreqStack()` 构造一个空的堆栈。

- `void push(int val)` 将一个整数 `val` 压入栈顶。

- ```
    int pop()
    ```

     删除并返回堆栈中出现频率最高的元素。

    - 如果出现频率最高的元素不只一个，则移除并返回最接近栈顶的元素。

**示例 1：**

```
输入：
["FreqStack","push","push","push","push","push","push","pop","pop","pop","pop"],
[[],[5],[7],[5],[7],[4],[5],[],[],[],[]]
输出：[null,null,null,null,null,null,null,5,7,5,4]
解释：
FreqStack = new FreqStack();
freqStack.push (5);//堆栈为 [5]
freqStack.push (7);//堆栈是 [5,7]
freqStack.push (5);//堆栈是 [5,7,5]
freqStack.push (7);//堆栈是 [5,7,5,7]
freqStack.push (4);//堆栈是 [5,7,5,7,4]
freqStack.push (5);//堆栈是 [5,7,5,7,4,5]
freqStack.pop ();//返回 5 ，因为 5 出现频率最高。堆栈变成 [5,7,5,7,4]。
freqStack.pop ();//返回 7 ，因为 5 和 7 出现频率最高，但7最接近顶部。堆栈变成 [5,7,5,4]。
freqStack.pop ();//返回 5 ，因为 5 出现频率最高。堆栈变成 [5,7,4]。
freqStack.pop ();//返回 4 ，因为 4, 5 和 7 出现频率最高，但 4 是最接近顶部的。堆栈变成 [5,7]。
```

```go

```

#### [140. 单词拆分 II](https://leetcode.cn/problems/word-break-ii/)

给定一个字符串 `s` 和一个字符串字典 `wordDict` ，在字符串 `s` 中增加空格来构建一个句子，使得句子中所有的单词都在词典中。**以任意顺序** 返回所有这些可能的句子。

**注意：**词典中的同一个单词可能在分段中被重复使用多次。

**示例 1：**

```
输入:s = "catsanddog", wordDict = ["cat","cats","and","sand","dog"]
输出:["cats and dog","cat sand dog"]
```

**示例 2：**

```
输入:s = "pineapplepenapple", wordDict = ["apple","pen","applepen","pine","pineapple"]
输出:["pine apple pen apple","pineapple pen apple","pine applepen apple"]
解释: 注意你可以重复使用字典中的单词。
```

**示例 3：**

```
输入:s = "catsandog", wordDict = ["cats","dog","sand","and","cat"]
输出:[]
```

```go

```

#### [321. 拼接最大数](https://leetcode.cn/problems/create-maximum-number/)

给定长度分别为 `m` 和 `n` 的两个数组，其元素由 `0-9` 构成，表示两个自然数各位上的数字。现在从这两个数组中选出 `k (k <= m + n)` 个数字拼接成一个新的数，要求从同一个数组中取出的数字保持其在原数组中的相对顺序。

求满足该条件的最大数。结果返回一个表示该最大数的长度为 `k` 的数组。

**说明:** 请尽可能地优化你算法的时间和空间复杂度。

**示例 1:**

```
输入:
nums1 = [3, 4, 6, 5]
nums2 = [9, 1, 2, 5, 8, 3]
k = 5
输出:
[9, 8, 6, 5, 3]
```

**示例 2:**

```
输入:
nums1 = [6, 7]
nums2 = [6, 0, 4]
k = 5
输出:
[6, 7, 6, 0, 4]
```

**示例 3:**

```
输入:
nums1 = [3, 9]
nums2 = [8, 9]
k = 3
输出:
[9, 8, 9]
```

```go

```

#### [60. 排列序列](https://leetcode.cn/problems/permutation-sequence/)

给出集合 `[1,2,3,...,n]`，其所有元素共有 `n!` 种排列。

按大小顺序列出所有排列情况，并一一标记，当 `n = 3` 时, 所有排列如下：

1. `"123"`
2. `"132"`
3. `"213"`
4. `"231"`
5. `"312"`
6. `"321"`

给定 `n` 和 `k`，返回第 `k` 个排列。

**示例 1：**

```
输入：n = 3, k = 3
输出："213"
```

**示例 2：**

```
输入：n = 4, k = 9
输出："2314"
```

**示例 3：**

```
输入：n = 3, k = 1
输出："123"
```

```go

```

#### [315. 计算右侧小于当前元素的个数](https://leetcode.cn/problems/count-of-smaller-numbers-after-self/)

给你一个整数数组 `nums` ，按要求返回一个新数组 `counts` 。数组 `counts` 有该性质： `counts[i]` 的值是 `nums[i]` 右侧小于 `nums[i]` 的元素的数量。

**示例 1：**

```
输入：nums = [5,2,6,1]
输出：[2,1,1,0] 
解释：
5 的右侧有 2 个更小的元素 (2 和 1)
2 的右侧仅有 1 个更小的元素 (1)
6 的右侧有 1 个更小的元素 (1)
1 的右侧有 0 个更小的元素
```

**示例 2：**

```
输入：nums = [-1]
输出：[0]
```

**示例 3：**

```
输入：nums = [-1,-1]
输出：[0,0]
```

```go

```

#### [1095. 山脉数组中查找目标值](https://leetcode.cn/problems/find-in-mountain-array/)

（这是一个 **交互式问题** ）

给你一个 **山脉数组** `mountainArr`，请你返回能够使得 `mountainArr.get(index)` **等于** `target` **最小** 的下标 `index` 值。

如果不存在这样的下标 `index`，就请返回 `-1`。

何为山脉数组？如果数组 `A` 是一个山脉数组的话，那它满足如下条件：

**首先**，`A.length >= 3`

**其次**，在 `0 < i < A.length - 1` 条件下，存在 `i` 使得：

- `A[0] < A[1] < ... A[i-1] < A[i]`
- `A[i] > A[i+1] > ... > A[A.length - 1]`

你将 **不能直接访问该山脉数组**，必须通过 `MountainArray` 接口来获取数据：

- `MountainArray.get(k)` - 会返回数组中索引为`k` 的元素（下标从 0 开始）
- `MountainArray.length()` - 会返回该数组的长度

```go

```

#### [37. 解数独](https://leetcode.cn/problems/sudoku-solver/)

编写一个程序，通过填充空格来解决数独问题。

数独的解法需 **遵循如下规则**：

1. 数字 `1-9` 在每一行只能出现一次。
2. 数字 `1-9` 在每一列只能出现一次。
3. 数字 `1-9` 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。（请参考示例图）

数独部分空格内已填入了数字，空白格用 `'.'` 表示。

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714svg.png)

```
输入：board = [["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]]
输出：[["5","3","4","6","7","8","9","1","2"],["6","7","2","1","9","5","3","4","8"],["1","9","8","3","4","2","5","6","7"],["8","5","9","7","6","1","4","2","3"],["4","2","6","8","5","3","7","9","1"],["7","1","3","9","2","4","8","5","6"],["9","6","1","5","3","7","2","8","4"],["2","8","7","4","1","9","6","3","5"],["3","4","5","2","8","6","1","7","9"]]
解释：输入的数独如上图所示，唯一有效的解决方案如下所示：
```

```go

```

#### [410. 分割数组的最大值](https://leetcode.cn/problems/split-array-largest-sum/)

给定一个非负整数数组 `nums` 和一个整数 `m` ，你需要将这个数组分成 `m` 个非空的连续子数组。

设计一个算法使得这 `m` 个子数组各自和的最大值最小。

**示例 1：**

```
输入：nums = [7,2,5,10,8], m = 2
输出：18
解释：
一共有四种方法将 nums 分割为 2 个子数组。 
其中最好的方式是将其分为 [7,2,5] 和 [10,8] 。
因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。
```

**示例 2：**

```
输入：nums = [1,2,3,4,5], m = 2
输出：9
```

**示例 3：**

```
输入：nums = [1,4,4], m = 3
输出：4
```

```go

```

#### [115. 不同的子序列](https://leetcode.cn/problems/distinct-subsequences/)

给定一个字符串 `s` 和一个字符串 `t` ，计算在 `s` 的子序列中 `t` 出现的个数。

字符串的一个 **子序列** 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，`"ACE"` 是 `"ABCDE"` 的一个子序列，而 `"AEC"` 不是）

题目数据保证答案符合 32 位带符号整数范围。

**示例 1：**

```
输入：s = "rabbbit", t = "rabbit"
输出：3
解释：
如下图所示, 有 3 种可以从 s 中得到 "rabbit" 的方案。
rabbbit
rabbbit
rabbbit
```

**示例 2：**

```
输入：s = "babgbag", t = "bag"
输出：5
解释：
如下图所示, 有 5 种可以从 s 中得到 "bag" 的方案。 
babgbag
babgbag
babgbag
babgbag
babgbag
```

```go

```

#### [407. 接雨水 II](https://leetcode.cn/problems/trapping-rain-water-ii/)

给你一个 `m x n` 的矩阵，其中的值均为非负整数，代表二维高度图每个单元的高度，请计算图中形状最多能接多少体积的雨水。

**示例 1:**

![img](https://assets.leetcode.com/uploads/2021/04/08/trap1-3d.jpg)

```
输入: heightMap = [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]
输出: 4
解释: 下雨后，雨水将会被上图蓝色的方块中。总的接雨水量为1+2+1=4。
```

**示例 2:**

![img](https://assets.leetcode.com/uploads/2021/04/08/trap2-3d.jpg)

```
输入: heightMap = [[3,3,3,3,3],[3,2,2,2,3],[3,2,1,2,3],[3,2,2,2,3],[3,3,3,3,3]]
输出: 10
```

```go

```

